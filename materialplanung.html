<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Materialplanung</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f4f4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            background-color: #34495e;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background-color: #34495e;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s;
        }

        .tab:hover {
            background-color: #2c3e50;
        }

        .tab.active {
            background-color: #3498db;
        }

        .tab-content {
            background-color: white;
            padding: 20px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        textarea {
            height: 100px;
            resize: vertical;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.danger {
            background-color: #e74c3c;
        }

        button.danger:hover {
            background-color: #c0392b;
        }

        button.success {
            background-color: #27ae60;
        }

        button.success:hover {
            background-color: #229954;
        }

        .file-input {
            margin-bottom: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }

        .actions {
            white-space: nowrap;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            position: relative;
        }

        .alert.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .alert-title {
            font-weight: bold;
            margin: 0;
        }

        .alert-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .alert-btn {
            background: none;
            border: 1px solid currentColor;
            color: inherit;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .alert-btn:hover {
            opacity: 1;
            background-color: rgba(0,0,0,0.05);
        }

        .alert-content {
            margin-top: 10px;
        }

        .show-more-btn {
            background: none;
            border: none;
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            padding: 5px 0;
            margin-top: 10px;
            font-size: 13px;
            opacity: 0.8;
        }

        .show-more-btn:hover {
            opacity: 1;
        }

        .hidden-content {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }

        .hidden-content.visible {
            display: block;
        }

        .correction-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid rgba(0,0,0,0.1);
            background-color: rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 12px;
        }

        .correction-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: inherit;
        }

        .correction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px;
            background-color: rgba(255,255,255,0.2);
            border-radius: 3px;
            font-size: 13px;
        }

        .correction-description {
            flex-grow: 1;
            margin-right: 10px;
        }

        .correction-btn {
            background: rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.2);
            color: inherit;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .correction-btn:hover {
            background: rgba(0,0,0,0.2);
        }

        .correction-btn.applied {
            background: rgba(0,128,0,0.3);
            border-color: rgba(0,128,0,0.5);
        }

        .bulk-corrections {
            margin-top: 10px;
            text-align: center;
        }

        .bulk-correction-btn {
            background: rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.3);
            color: inherit;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 0 5px;
            transition: all 0.2s;
        }

        .bulk-correction-btn:hover {
            background: rgba(0,0,0,0.2);
        }

        .hidden {
            display: none;
        }

        .bom-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .bom-item select, .bom-item input {
            margin-right: 10px;
            width: auto;
            min-width: 150px;
        }

        .requirements-result {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Materialplanung System</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('products')">Produkte</button>
            <button class="tab" onclick="showTab('boms')">St√ºcklisten</button>
            <button class="tab" onclick="showTab('inventory')">Lagerstand</button>
            <button class="tab" onclick="showTab('demand')">Bedarf</button>
            <button class="tab" onclick="showTab('requirements')">Bedarfsermittlung</button>
            <button class="tab" onclick="showTab('data')">Daten</button>
        </div>

        <div class="tab-content">
            <!-- Produkte Tab -->
            <div id="products" class="tab-panel active">
                <div class="grid">
                    <div class="card">
                        <h3>Neues Produkt anlegen</h3>
                        <form id="productForm">
                            <div class="form-group">
                                <label for="productNumber">Produktnummer:</label>
                                <input type="text" id="productNumber" required>
                            </div>
                            <div class="form-group">
                                <label for="productName">Artikelname:</label>
                                <input type="text" id="productName" required>
                            </div>
                            <div class="form-group">
                                <label for="productCost">Kosten (‚Ç¨):</label>
                                <input type="number" id="productCost" step="0.01" required>
                            </div>
                            <button type="submit">Produkt hinzuf√ºgen</button>
                        </form>
                    </div>
                    <div class="card">
                        <h3>CSV Import - Produkte</h3>
                        <div class="file-input">
                            <label for="productsCSV">Produktliste (CSV):</label>
                            <input type="file" id="productsCSV" accept=".csv">
                            <small>Format: Produktnummer; Artikelname; Kosten</small>
                        </div>
                        <button onclick="importProductsCSV()">Produkte importieren</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Produktliste</h3>
                    <button onclick="clearAllProducts()" class="danger" style="margin-bottom: 15px;">Alle Produkte l√∂schen</button>
                    <table id="productsTable">
                        <thead>
                            <tr>
                                <th>Produktnummer</th>
                                <th>Artikelname</th>
                                <th>Kosten (‚Ç¨)</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- St√ºcklisten Tab -->
            <div id="boms" class="tab-panel">
                <div class="grid">
                    <div class="card">
                        <h3>Neue St√ºckliste anlegen</h3>
                        <form id="bomForm">
                            <div class="form-group">
                                <label for="bomProduct">Hauptprodukt:</label>
                                <select id="bomProduct" required></select>
                            </div>
                            <div class="form-group">
                                <label>Bauteile:</label>
                                <div id="bomItems"></div>
                                <button type="button" onclick="addBomItem()">Bauteil hinzuf√ºgen</button>
                            </div>
                            <button type="submit">St√ºckliste speichern</button>
                        </form>
                    </div>
                    <div class="card">
                        <h3>CSV Import - St√ºcklisten</h3>
                        <div class="file-input">
                            <label for="bomsCSV">St√ºcklisten (CSV):</label>
                            <input type="file" id="bomsCSV" accept=".csv">
                            <small>Format: Hauptprodukt; Bauteil; Menge</small>
                        </div>
                        <button onclick="importBomsCSV()">St√ºcklisten importieren</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>St√ºcklisten √úbersicht</h3>
                    <button onclick="clearAllBoms()" class="danger" style="margin-bottom: 15px;">Alle St√ºcklisten l√∂schen</button>
                    <div id="bomsDisplay"></div>
                </div>
            </div>

            <!-- Lagerstand Tab -->
            <div id="inventory" class="tab-panel">
                <div class="grid">
                    <div class="card">
                        <h3>Lagerstand manuell bearbeiten</h3>
                        <form id="inventoryForm">
                            <div class="form-group">
                                <label for="inventoryProduct">Produkt:</label>
                                <select id="inventoryProduct" required></select>
                            </div>
                            <div class="form-group">
                                <label for="inventoryQuantity">Menge:</label>
                                <input type="number" id="inventoryQuantity" required>
                            </div>
                            <button type="submit">Lagerstand aktualisieren</button>
                        </form>
                    </div>
                    <div class="card">
                        <h3>CSV Import - Lagerstand</h3>
                        <div class="file-input">
                            <label for="inventoryCSV">Lagerstand (CSV):</label>
                            <input type="file" id="inventoryCSV" accept=".csv">
                            <small>Format: Produktnummer; Menge</small>
                        </div>
                        <button onclick="importInventoryCSV()">Lagerstand importieren</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Aktueller Lagerstand</h3>
                    <button onclick="clearAllInventory()" class="danger" style="margin-bottom: 15px;">Gesamten Lagerstand l√∂schen</button>
                    <table id="inventoryTable">
                        <thead>
                            <tr>
                                <th>Produktnummer</th>
                                <th>Artikelname</th>
                                <th>Menge</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- Bedarf Tab -->
            <div id="demand" class="tab-panel">
                <div class="grid">
                    <div class="card">
                        <h3>Bedarf manuell eingeben</h3>
                        <form id="demandForm">
                            <div class="form-group">
                                <label for="demandProduct">Hauptprodukt:</label>
                                <input type="text" id="demandProduct" list="demandProductList" placeholder="Produktnummer oder Name eingeben..." required>
                                <datalist id="demandProductList"></datalist>
                                <small>Tippe um zu suchen oder w√§hle aus der Liste</small>
                            </div>
                            <div class="form-group">
                                <label for="demandQuantity">Ben√∂tigte Menge:</label>
                                <input type="number" id="demandQuantity" required>
                            </div>
                            <button type="submit">Bedarf hinzuf√ºgen</button>
                        </form>
                    </div>
                    <div class="card">
                        <h3>CSV Import - Bedarf</h3>
                        <div class="file-input">
                            <label for="demandCSV">Bedarf (CSV):</label>
                            <input type="file" id="demandCSV" accept=".csv">
                            <small>Format: Produktnummer; Menge</small>
                        </div>
                        <button onclick="importDemandCSV()">Bedarf importieren</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Aktueller Bedarf</h3>
                    <button onclick="clearAllDemand()" class="danger" style="margin-bottom: 15px;">Gesamten Bedarf l√∂schen</button>
                    <table id="demandTable">
                        <thead>
                            <tr>
                                <th>Produktnummer</th>
                                <th>Artikelname</th>
                                <th>Ben√∂tigte Menge</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- Bedarfsermittlung Tab -->
            <div id="requirements" class="tab-panel">
                <div class="card">
                    <h3>Bedarfsermittlung</h3>
                    <p>Hier wird basierend auf dem Bedarf, den St√ºcklisten und dem Lagerstand ermittelt, welche Materialien bestellt werden m√ºssen.</p>
                    <button onclick="calculateRequirements()" class="success">Bedarfsermittlung durchf√ºhren</button>
                    <button onclick="clearRequirementsResult()" class="danger">Ergebnis l√∂schen</button>
                    <div id="requirementsResult"></div>
                </div>
            </div>

            <!-- Daten Tab -->
            <div id="data" class="tab-panel">
                <div class="grid">
                    <div class="card">
                        <h3>Daten exportieren</h3>
                        <button onclick="exportData()" class="success">JSON Backup herunterladen</button>
                        <p><small>L√§dt alle Daten als JSON-Datei herunter</small></p>
                    </div>
                    <div class="card">
                        <h3>Daten importieren</h3>
                        <div class="file-input">
                            <label for="dataImport">JSON Backup:</label>
                            <input type="file" id="dataImport" accept=".json">
                        </div>
                        <button onclick="importData()">Daten importieren</button>
                        <p><small>L√§dt alle Daten aus einer JSON-Backup-Datei</small></p>
                    </div>
                </div>
                
                <div class="card">
                    <h3>System-Check</h3>
                    <button onclick="showCriticalSituations()">üîç System-Check durchf√ºhren</button>
                    <p><small>√úberpr√ºft das System auf kritische Situationen und Inkonsistenzen</small></p>
                </div>
                
                <div class="card">
                    <h3>Daten l√∂schen</h3>
                    <button onclick="clearAllData()" class="danger">Alle Daten l√∂schen</button>
                    <p><small>Achtung: Dieser Vorgang kann nicht r√ºckg√§ngig gemacht werden!</small></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Datenstrukturen
        let products = {};
        let boms = {};
        let inventory = {};
        let demand = {};

        // App initialisieren
        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            updateProductSelects();
            renderTables();
        });

        // Tab-Funktionalit√§t
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            // Tab-Button aktivieren
            const targetTab = document.querySelector(`.tab[onclick*="${tabName}"]`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            
            document.getElementById(tabName).classList.add('active');
        }

        // Daten laden und speichern
        function loadData() {
            const savedData = localStorage.getItem('materialplanung');
            if (savedData) {
                const data = JSON.parse(savedData);
                products = data.products || {};
                boms = data.boms || {};
                inventory = data.inventory || {};
                demand = data.demand || {};
            }
        }

        function saveData() {
            const data = { products, boms, inventory, demand };
            localStorage.setItem('materialplanung', JSON.stringify(data));
        }

        // Erweiterte Validierung f√ºr manuelle Eingaben
        function validateManualProductInput(productNumber, productName, productCost) {
            const validation = validateProductData(productNumber, productName, productCost);
            
            // Zus√§tzliche Pr√ºfungen f√ºr manuelle Eingabe
            if (products[productNumber]) {
                validation.errors.push('Produktnummer bereits vorhanden!');
            }
            
            return validation;
        }

        function validateManualBOMInput(mainProduct, bomItems) {
            const errors = [];
            const warnings = [];
            
            if (!mainProduct) {
                errors.push('Hauptprodukt muss ausgew√§hlt werden');
                return { errors, warnings };
            }
            
            if (!products[mainProduct]) {
                warnings.push(`Hauptprodukt "${mainProduct}" existiert nicht in der Produktliste`);
            }
            
            const components = [];
            let hasValidComponents = false;
            
            bomItems.forEach((item, index) => {
                const component = item.querySelector('select').value;
                const quantity = item.querySelector('input').value;
                
                if (component || quantity) { // Nur validieren wenn mindestens ein Feld ausgef√ºllt
                    const bomValidation = validateBOMData(mainProduct, component, quantity);
                    
                    bomValidation.errors.forEach(error => {
                        errors.push(`Bauteil ${index + 1}: ${error}`);
                    });
                    bomValidation.warnings.forEach(warning => {
                        warnings.push(`Bauteil ${index + 1}: ${warning}`);
                    });
                    
                    if (component && quantity && !isNaN(parseInt(quantity)) && parseInt(quantity) > 0) {
                        if (components.includes(component)) {
                            warnings.push(`Bauteil ${index + 1}: Komponente "${component}" bereits vorhanden`);
                        } else {
                            components.push(component);
                            hasValidComponents = true;
                        }
                    }
                }
            });
            
            if (!hasValidComponents) {
                errors.push('Mindestens eine g√ºltige Komponente erforderlich');
            }
            
            return { errors, warnings };
        }

        // Produkte verwalten
        document.getElementById('productForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const productNumber = document.getElementById('productNumber').value.trim();
            const productName = document.getElementById('productName').value.trim();
            const productCost = document.getElementById('productCost').value;
            
            const validation = validateManualProductInput(productNumber, productName, productCost);
            
            if (validation.errors.length > 0) {
                showAlert(`Eingabefehler:\n${validation.errors.join('\n')}`, 'error');
                return;
            }
            
            if (validation.warnings.length > 0) {
                const proceed = confirm(`Warnungen:\n${validation.warnings.join('\n')}\n\nTrotzdem fortfahren?`);
                if (!proceed) return;
            }
            
            products[productNumber] = {
                name: productName,
                cost: parseFloat(productCost) || 0
            };
            
            saveData();
            updateProductSelects();
            renderTables();
            this.reset();
            showAlert('Produkt erfolgreich hinzugef√ºgt!', 'success');
        });

        function editProduct(productNumber) {
            const product = products[productNumber];
            
            const newProductNumber = prompt('Neue Produktnummer:', productNumber);
            if (!newProductNumber || newProductNumber === productNumber) {
                return; // Abgebrochen oder keine √Ñnderung
            }
            
            if (products[newProductNumber]) {
                showAlert('Produktnummer bereits vorhanden!', 'error');
                return;
            }
            
            const newProductName = prompt('Neuer Artikelname:', product.name);
            if (!newProductName) return;
            
            const newCost = prompt('Neue Kosten (‚Ç¨):', product.cost);
            if (!newCost || isNaN(parseFloat(newCost))) return;
            
            // Altes Produkt l√∂schen
            delete products[productNumber];
            
            // Neues Produkt hinzuf√ºgen
            products[newProductNumber] = {
                name: newProductName,
                cost: parseFloat(newCost)
            };
            
            // Referenzen in anderen Daten aktualisieren
            if (inventory[productNumber]) {
                inventory[newProductNumber] = inventory[productNumber];
                delete inventory[productNumber];
            }
            
            if (demand[productNumber]) {
                demand[newProductNumber] = demand[productNumber];
                delete demand[productNumber];
            }
            
            // In St√ºcklisten aktualisieren
            Object.keys(boms).forEach(bomKey => {
                if (bomKey === productNumber) {
                    // Hauptprodukt-St√ºckliste umbenennen
                    boms[newProductNumber] = boms[productNumber];
                    delete boms[productNumber];
                } else if (boms[bomKey][productNumber]) {
                    // Als Komponente in anderen St√ºcklisten
                    boms[bomKey][newProductNumber] = boms[bomKey][productNumber];
                    delete boms[bomKey][productNumber];
                }
            });
            
            saveData();
            updateProductSelects();
            renderTables();
            showAlert('Produkt erfolgreich bearbeitet!', 'success');
        }

        function deleteProduct(productNumber) {
            if (confirm('Produkt wirklich l√∂schen?')) {
                delete products[productNumber];
                delete inventory[productNumber];
                delete demand[productNumber];
                
                // Aus St√ºcklisten entfernen
                Object.keys(boms).forEach(bomKey => {
                    if (bomKey === productNumber) {
                        delete boms[bomKey];
                    } else if (boms[bomKey][productNumber]) {
                        delete boms[bomKey][productNumber];
                    }
                });
                
                saveData();
                updateProductSelects();
                renderTables();
                showAlert('Produkt gel√∂scht!', 'success');
            }
        }

        // St√ºcklisten verwalten
        function addBomItem() {
            const bomItems = document.getElementById('bomItems');
            const itemDiv = document.createElement('div');
            itemDiv.className = 'bom-item';
            
            itemDiv.innerHTML = `
                <select required>
                    <option value="">Bauteil w√§hlen...</option>
                    ${Object.keys(products).map(key => 
                        `<option value="${key}">${key} - ${products[key].name}</option>`
                    ).join('')}
                </select>
                <input type="number" placeholder="Menge" required min="1">
                <button type="button" onclick="this.parentElement.remove()">Entfernen</button>
            `;
            
            bomItems.appendChild(itemDiv);
        }

        document.getElementById('bomForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const productNumber = document.getElementById('bomProduct').value;
            const bomItems = document.querySelectorAll('#bomItems .bom-item');
            
            const validation = validateManualBOMInput(productNumber, bomItems);
            
            if (validation.errors.length > 0) {
                showAlert(`St√ºcklisten-Fehler:\n${validation.errors.join('\n')}`, 'error');
                return;
            }
            
            if (validation.warnings.length > 0) {
                const proceed = confirm(`Warnungen:\n${validation.warnings.join('\n')}\n\nTrotzdem fortfahren?`);
                if (!proceed) return;
            }
            
            // Erstelle BOM-Daten
            const bomData = {};
            bomItems.forEach(item => {
                const component = item.querySelector('select').value;
                const quantity = parseInt(item.querySelector('input').value);
                
                if (component && quantity > 0) {
                    bomData[component] = quantity;
                }
            });
            
            // Pr√ºfe auf Zyklus VOR dem Speichern
            const tempBoms = { ...boms };
            tempBoms[productNumber] = bomData;
            
            if (wouldCreateCycle(productNumber, tempBoms)) {
                showAlert('Fehler: Diese St√ºckliste w√ºrde eine zirkul√§re Referenz erzeugen!', 'error');
                return;
            }
            
            boms[productNumber] = bomData;
            saveData();
            renderBoms();
            this.reset();
            document.getElementById('bomItems').innerHTML = '';
            showAlert('St√ºckliste gespeichert!', 'success');
        });

        // Pr√ºft ob eine St√ºckliste einen Zyklus erzeugen w√ºrde
        function wouldCreateCycle(productNumber, testBoms) {
            function hasPath(from, to, visited = new Set()) {
                if (from === to) return true;
                if (visited.has(from)) return false;
                
                visited.add(from);
                
                if (testBoms[from]) {
                    for (const component of Object.keys(testBoms[from])) {
                        if (hasPath(component, to, visited)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Pr√ºfe ob irgendeine Komponente einen Weg zur√ºck zum Hauptprodukt hat
            if (testBoms[productNumber]) {
                for (const component of Object.keys(testBoms[productNumber])) {
                    if (hasPath(component, productNumber, new Set())) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Lagerstand verwalten
        document.getElementById('inventoryForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const productNumber = document.getElementById('inventoryProduct').value;
            const quantity = document.getElementById('inventoryQuantity').value;
            
            const validation = validateInventoryData(productNumber, quantity);
            
            if (validation.errors.length > 0) {
                showAlert(`Lagerstand-Fehler:\n${validation.errors.join('\n')}`, 'error');
                return;
            }
            
            if (validation.warnings.length > 0) {
                const proceed = confirm(`Warnungen:\n${validation.warnings.join('\n')}\n\nTrotzdem fortfahren?`);
                if (!proceed) return;
            }
            
            inventory[productNumber] = parseInt(quantity) || 0;
            saveData();
            renderTables();
            this.reset();
            showAlert('Lagerstand aktualisiert!', 'success');
        });

        // Echtzeit-Suche f√ºr Bedarf-Produktauswahl
        document.getElementById('demandProduct').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            updateDemandProductList(searchTerm);
        });

        // Bedarf verwalten
        document.getElementById('demandForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const productInput = document.getElementById('demandProduct').value.trim();
            const quantity = parseInt(document.getElementById('demandQuantity').value);
            
            // Produktnummer extrahieren (falls Format "Nummer - Name" oder "Name (Nummer)")
            let productNumber = productInput;
            
            // Pr√ºfe verschiedene Eingabeformate
            if (productInput.includes(' - ')) {
                // Format: "100001 - Produktname"
                productNumber = productInput.split(' - ')[0].trim();
            } else if (productInput.includes('(') && productInput.includes(')')) {
                // Format: "Produktname (100001)"
                const match = productInput.match(/\(([^)]+)\)/);
                if (match) {
                    productNumber = match[1].trim();
                }
            } else {
                // Direkte Eingabe der Produktnummer oder Produktname
                // Pr√ºfe ob es eine g√ºltige Produktnummer ist
                if (!products[productInput]) {
                    // Suche nach Produktname
                    const foundProduct = Object.keys(products).find(key => 
                        products[key].name.toLowerCase().includes(productInput.toLowerCase())
                    );
                    if (foundProduct) {
                        productNumber = foundProduct;
                    }
                }
            }
            
            // Validierung
            if (!products[productNumber]) {
                showAlert(`Produkt "${productInput}" nicht gefunden! Bitte g√ºltige Produktnummer oder -name eingeben.`, 'error');
                return;
            }
            
            demand[productNumber] = (demand[productNumber] || 0) + quantity;
            saveData();
            renderTables();
            this.reset();
            showAlert(`Bedarf f√ºr ${productNumber} - ${products[productNumber].name} hinzugef√ºgt!`, 'success');
        });

        // Erweiterte Validierungsfunktionen
        function validateProductData(productNumber, productName, cost) {
            const errors = [];
            const warnings = [];
            
            // Produktnummer validieren
            if (!productNumber || productNumber.trim() === '') {
                errors.push('Produktnummer ist erforderlich');
            } else if (productNumber.length > 20) {
                warnings.push(`Produktnummer "${productNumber}" ist sehr lang (>20 Zeichen)`);
            } else if (!/^[a-zA-Z0-9\-_]+$/.test(productNumber)) {
                warnings.push(`Produktnummer "${productNumber}" enth√§lt Sonderzeichen`);
            }
            
            // Produktname validieren
            if (!productName || productName.trim() === '') {
                errors.push('Produktname ist erforderlich');
            } else if (productName.length > 100) {
                warnings.push(`Produktname ist sehr lang (>100 Zeichen)`);
            }
            
            // Kosten validieren
            if (cost === null || cost === undefined || cost === '') {
                warnings.push('Kosten nicht angegeben (wird auf 0 gesetzt)');
            } else if (isNaN(parseFloat(cost))) {
                errors.push(`Ung√ºltige Kosten: "${cost}"`);
            } else {
                const numCost = parseFloat(cost);
                if (numCost < 0) {
                    warnings.push('Negative Kosten sind ungew√∂hnlich');
                } else if (numCost > 100000) {
                    warnings.push(`Sehr hohe Kosten: ${numCost.toFixed(2)}‚Ç¨`);
                }
            }
            
            return { errors, warnings };
        }

        function validateBOMData(mainProduct, component, quantity) {
            const errors = [];
            const warnings = [];
            
            // Hauptprodukt pr√ºfen
            if (!mainProduct || mainProduct.trim() === '') {
                errors.push('Hauptprodukt ist erforderlich');
            } else if (!products[mainProduct]) {
                warnings.push(`Hauptprodukt "${mainProduct}" existiert nicht in der Produktliste`);
            }
            
            // Komponente pr√ºfen
            if (!component || component.trim() === '') {
                errors.push('Komponente ist erforderlich');
            } else if (!products[component]) {
                warnings.push(`Komponente "${component}" existiert nicht in der Produktliste`);
            }
            
            // Selbstreferenz pr√ºfen
            if (mainProduct === component) {
                errors.push(`Selbstreferenz: "${mainProduct}" kann sich nicht selbst enthalten`);
            }
            
            // Menge pr√ºfen
            if (!quantity || quantity === '') {
                errors.push('Menge ist erforderlich');
            } else if (isNaN(parseInt(quantity))) {
                errors.push(`Ung√ºltige Menge: "${quantity}"`);
            } else {
                const numQuantity = parseInt(quantity);
                if (numQuantity <= 0) {
                    errors.push('Menge muss gr√∂√üer als 0 sein');
                } else if (numQuantity > 1000) {
                    warnings.push(`Sehr hohe Menge: ${numQuantity}`);
                }
            }
            
            return { errors, warnings };
        }

        function validateInventoryData(productNumber, quantity) {
            const errors = [];
            const warnings = [];
            
            // Produktnummer pr√ºfen
            if (!productNumber || productNumber.trim() === '') {
                errors.push('Produktnummer ist erforderlich');
            } else if (!products[productNumber]) {
                warnings.push(`Produkt "${productNumber}" existiert nicht in der Produktliste`);
            }
            
            // Menge pr√ºfen
            if (quantity === null || quantity === undefined || quantity === '') {
                warnings.push('Menge nicht angegeben (wird auf 0 gesetzt)');
            } else if (isNaN(parseInt(quantity))) {
                errors.push(`Ung√ºltige Menge: "${quantity}"`);
            } else {
                const numQuantity = parseInt(quantity);
                if (numQuantity < 0) {
                    warnings.push('Negative Lagerbest√§nde sind ungew√∂hnlich');
                } else if (numQuantity > 100000) {
                    warnings.push(`Sehr hoher Lagerbestand: ${numQuantity}`);
                }
            }
            
            return { errors, warnings };
        }

        function checkForDuplicates(data, keyField) {
            const seen = new Set();
            const duplicates = [];
            
            data.forEach((item, index) => {
                const key = item[keyField];
                if (key && seen.has(key)) {
                    duplicates.push({ key, line: index + 1 });
                } else if (key) {
                    seen.add(key);
                }
            });
            
            return duplicates;
        }

        function showValidationSummary(imported, errors, warnings, duplicates, fileName) {
            const alertType = errors.length > 0 ? 'error' : (warnings.length > 0 || duplicates.length > 0) ? 'warning' : 'success';
            const hasIssues = errors.length > 0 || warnings.length > 0 || duplicates.length > 0;
            
            // Import-Validierung: Persistent wenn Probleme vorhanden, Export-Option bei gr√∂√üeren Problem-Listen
            const isPersistent = hasIssues && (errors.length > 0 || warnings.length > 5 || duplicates.length > 5);
            const hasExportData = errors.length > 3 || warnings.length > 5 || duplicates.length > 3;
            
            // Erstelle erweiterte Alert-Daten mit vollst√§ndigen Listen und Korrekturen
            const alertData = {
                summary: `${fileName}: ${imported} Eintr√§ge importiert`,
                errors: errors,
                warnings: warnings,  
                duplicates: duplicates,
                fullMessage: createFullValidationMessage(fileName, imported, errors, warnings, duplicates),
                corrections: generateCorrections(errors, warnings, duplicates)
            };
            
            showExpandableAlert(alertData, alertType, { 
                title: `Import-Validierung: ${fileName}`,
                persistent: isPersistent,
                exportData: hasExportData,
                showCorrections: hasIssues
            });
        }

        function createFullValidationMessage(fileName, imported, errors, warnings, duplicates) {
            let message = `${fileName}: ${imported} Eintr√§ge importiert`;
            
            if (errors.length > 0) {
                message += `\n\n‚ùå ${errors.length} Fehler:\n${errors.join('\n')}`;
            }
            
            if (warnings.length > 0) {
                message += `\n\n‚ö†Ô∏è ${warnings.length} Warnungen:\n${warnings.join('\n')}`;
            }
            
            if (duplicates.length > 0) {
                message += `\n\nüîÑ ${duplicates.length} Duplikate erkannt:`;
                duplicates.forEach(dup => {
                    message += `\n  - "${dup.key}" (Zeile ${dup.line})`;
                });
            }
            
            return message;
        }

        // Generiere m√∂gliche Korrekturen basierend auf Warnungen/Fehlern
        function generateCorrections(errors, warnings, duplicates) {
            const corrections = [];
            
            // 1. Fehlende Kosten korrigieren
            const missingCostWarnings = warnings.filter(w => w.includes('Kosten nicht angegeben'));
            if (missingCostWarnings.length > 0) {
                corrections.push({
                    type: 'missing_costs',
                    description: `${missingCostWarnings.length} Produkte ohne Kosten auf 0‚Ç¨ setzen`,
                    action: () => applyMissingCostCorrection(missingCostWarnings),
                    severity: 'low'
                });
            }
            
            // 2. Unbekannte Produkte erstellen
            const missingProductWarnings = warnings.filter(w => 
                w.includes('existiert nicht in der Produktliste') && 
                !w.includes('Hauptprodukt') // Nur Komponenten, nicht Hauptprodukte
            );
            if (missingProductWarnings.length > 0) {
                corrections.push({
                    type: 'missing_products',
                    description: `${missingProductWarnings.length} fehlende Produkte automatisch erstellen`,
                    action: () => applyMissingProductCorrection(missingProductWarnings),
                    severity: 'medium'
                });
            }
            
            // 3. Duplikate entfernen
            if (duplicates.length > 0) {
                corrections.push({
                    type: 'remove_duplicates',
                    description: `${duplicates.length} Duplikate aus Import-Daten entfernen`,
                    action: () => applyDuplicateCorrection(duplicates),
                    severity: 'medium'
                });
            }
            
            // 4. System-Check Korrekturen aus der globalen Warnung
            const systemWarnings = checkCriticalSituations();
            
            // Fehlende Komponenten in Produktliste erstellen
            const missingComponents = [];
            Object.keys(boms).forEach(bomKey => {
                Object.keys(boms[bomKey]).forEach(component => {
                    if (!products[component]) {
                        missingComponents.push(component);
                    }
                });
            });
            if (missingComponents.length > 0) {
                corrections.push({
                    type: 'create_missing_components',
                    description: `${missingComponents.length} fehlende St√ºcklisten-Komponenten als Produkte erstellen`,
                    action: () => applyMissingComponentCorrection(missingComponents),
                    severity: 'high'
                });
            }
            
            // Verwaiste Inventar-/Bedarf-Eintr√§ge bereinigen
            const orphanedInventory = Object.keys(inventory).filter(key => !products[key]);
            const orphanedDemand = Object.keys(demand).filter(key => !products[key]);
            if (orphanedInventory.length > 0 || orphanedDemand.length > 0) {
                corrections.push({
                    type: 'cleanup_orphaned',
                    description: `${orphanedInventory.length + orphanedDemand.length} verwaiste Eintr√§ge bereinigen`,
                    action: () => applyOrphanedCleanup(orphanedInventory, orphanedDemand),
                    severity: 'medium'
                });
            }
            
            return corrections.filter(c => c.description); // Nur g√ºltige Korrekturen
        }

        // Korrektur-Anwendungen
        function applyMissingCostCorrection(warnings) {
            let fixed = 0;
            warnings.forEach(warning => {
                // Extrahiere Produktnummer aus Warnung (Format: "Zeile X: ...")
                const match = warning.match(/Zeile [\d.]+: .* f√ºr "([^"]+)"/);
                if (match) {
                    const productNumber = match[1];
                    if (products[productNumber] && (!products[productNumber].cost || products[productNumber].cost === 0)) {
                        products[productNumber].cost = 0;
                        fixed++;
                    }
                }
            });
            
            if (fixed > 0) {
                saveData();
                renderTables();
                return `${fixed} Produkte mit Kosten 0‚Ç¨ aktualisiert`;
            }
            return 'Keine Korrekturen angewendet';
        }

        function applyMissingProductCorrection(warnings) {
            let created = 0;
            warnings.forEach(warning => {
                // Extrahiere Produktnummer aus verschiedenen Warnungsformaten
                let productNumber = null;
                
                // Format: "Komponente 'X' existiert nicht"
                let match = warning.match(/Komponente "([^"]+)" existiert nicht/);
                if (!match) {
                    // Format: "Zeile X: Komponente 'Y' existiert nicht"  
                    match = warning.match(/Komponente "([^"]+)" existiert nicht/);
                }
                
                if (match) {
                    productNumber = match[1];
                    if (productNumber && !products[productNumber]) {
                        products[productNumber] = {
                            name: `Auto-generiert: ${productNumber}`,
                            cost: 0
                        };
                        created++;
                    }
                }
            });
            
            if (created > 0) {
                saveData();
                updateProductSelects();
                renderTables();
                return `${created} Produkte automatisch erstellt`;
            }
            return 'Keine Produkte erstellt';
        }

        function applyMissingComponentCorrection(missingComponents) {
            let created = 0;
            missingComponents.forEach(component => {
                if (!products[component]) {
                    products[component] = {
                        name: `St√ºcklisten-Komponente: ${component}`,
                        cost: 0
                    };
                    created++;
                }
            });
            
            if (created > 0) {
                saveData();
                updateProductSelects();
                renderTables();
                return `${created} St√ºcklisten-Komponenten als Produkte erstellt`;
            }
            return 'Keine Komponenten erstellt';
        }

        function applyOrphanedCleanup(orphanedInventory, orphanedDemand) {
            let cleaned = 0;
            
            orphanedInventory.forEach(key => {
                delete inventory[key];
                cleaned++;
            });
            
            orphanedDemand.forEach(key => {
                delete demand[key];
                cleaned++;
            });
            
            if (cleaned > 0) {
                saveData();
                renderTables();
                return `${cleaned} verwaiste Eintr√§ge entfernt`;
            }
            return 'Keine Eintr√§ge bereinigt';
        }

        function applyDuplicateCorrection(duplicates) {
            // Diese Funktion ist haupts√§chlich informativ, da Duplikate bereits beim Import behandelt werden
            return `${duplicates.length} Duplikate wurden bereits beim Import zusammengef√ºhrt`;
        }

        function showExpandableAlert(alertData, type, options = {}) {
            const existingAlert = document.querySelector('.alert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            
            // Bestimme ob das Alert persistent sein soll
            const isPersistent = options.persistent !== false && (type === 'warning' || type === 'error' || alertData.fullMessage.length > 100);
            const hasExportableData = options.exportData || alertData.fullMessage.includes('\n');
            
            // Alert-Header mit Titel und Aktions-Buttons
            if (isPersistent || hasExportableData) {
                const alertHeader = document.createElement('div');
                alertHeader.className = 'alert-header';
                
                const titleElement = document.createElement('div');
                titleElement.className = 'alert-title';
                titleElement.textContent = getAlertTitle(type, options.title);
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'alert-actions';
                
                // Export-Button (wenn exportierbare Daten vorhanden)
                if (hasExportableData) {
                    const exportBtn = document.createElement('button');
                    exportBtn.className = 'alert-btn';
                    exportBtn.innerHTML = 'üìä Export';
                    exportBtn.title = 'Alle Details als Textdatei exportieren';
                    exportBtn.onclick = () => exportAlertData(alertData.fullMessage, type, options);
                    actionsDiv.appendChild(exportBtn);
                }
                
                // Schlie√üen-Button (f√ºr persistente Alerts)
                if (isPersistent) {
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'alert-btn';
                    closeBtn.innerHTML = '‚úï Schlie√üen';
                    closeBtn.title = 'Meldung schlie√üen';
                    closeBtn.onclick = () => alert.remove();
                    actionsDiv.appendChild(closeBtn);
                }
                
                alertHeader.appendChild(titleElement);
                alertHeader.appendChild(actionsDiv);
                alert.appendChild(alertHeader);
            }
            
            // Alert-Content mit zusammengefasster Ansicht
            const contentDiv = document.createElement('div');
            contentDiv.className = 'alert-content';
            
            let summaryMessage = alertData.summary;
            let hasHiddenContent = false;
            
            // Zeige limitierte Anzahl von Fehlern/Warnungen
            if (alertData.errors.length > 0) {
                summaryMessage += `\n‚ùå ${alertData.errors.length} Fehler:\n${alertData.errors.slice(0, 5).join('\n')}`;
                if (alertData.errors.length > 5) {
                    summaryMessage += `\n... und ${alertData.errors.length - 5} weitere Fehler`;
                    hasHiddenContent = true;
                }
            }
            
            if (alertData.warnings.length > 0) {
                summaryMessage += `\n‚ö†Ô∏è ${alertData.warnings.length} Warnungen:\n${alertData.warnings.slice(0, 3).join('\n')}`;
                if (alertData.warnings.length > 3) {
                    summaryMessage += `\n... und ${alertData.warnings.length - 3} weitere Warnungen`;
                    hasHiddenContent = true;
                }
            }
            
            if (alertData.duplicates.length > 0) {
                summaryMessage += `\nüîÑ ${alertData.duplicates.length} Duplikate erkannt:`;
                alertData.duplicates.slice(0, 3).forEach(dup => {
                    summaryMessage += `\n  - "${dup.key}" (Zeile ${dup.line})`;
                });
                if (alertData.duplicates.length > 3) {
                    summaryMessage += `\n  ... und ${alertData.duplicates.length - 3} weitere`;
                    hasHiddenContent = true;
                }
            }
            
            contentDiv.style.whiteSpace = 'pre-line';
            contentDiv.style.textAlign = 'left';
            contentDiv.style.maxHeight = isPersistent ? '400px' : '300px';
            contentDiv.style.overflowY = 'auto';
            contentDiv.textContent = summaryMessage;
            
            alert.appendChild(contentDiv);
            
            // "Alle anzeigen" Button hinzuf√ºgen wenn mehr Details vorhanden sind
            if (hasHiddenContent) {
                const showMoreBtn = document.createElement('button');
                showMoreBtn.className = 'show-more-btn';
                showMoreBtn.textContent = 'Alle Details anzeigen ‚ñº';
                
                const hiddenDiv = document.createElement('div');
                hiddenDiv.className = 'hidden-content';
                hiddenDiv.style.whiteSpace = 'pre-line';
                hiddenDiv.style.maxHeight = '300px';
                hiddenDiv.style.overflowY = 'auto';
                
                // Vollst√§ndige Details f√ºr versteckten Bereich
                let fullDetails = '';
                
                if (alertData.errors.length > 5) {
                    fullDetails += `‚ùå Alle ${alertData.errors.length} Fehler:\n${alertData.errors.join('\n')}\n\n`;
                }
                
                if (alertData.warnings.length > 3) {
                    fullDetails += `‚ö†Ô∏è Alle ${alertData.warnings.length} Warnungen:\n${alertData.warnings.join('\n')}\n\n`;
                }
                
                if (alertData.duplicates.length > 3) {
                    fullDetails += `üîÑ Alle ${alertData.duplicates.length} Duplikate:\n`;
                    alertData.duplicates.forEach(dup => {
                        fullDetails += `  - "${dup.key}" (Zeile ${dup.line})\n`;
                    });
                }
                
                hiddenDiv.textContent = fullDetails.trim();
                
                let isExpanded = false;
                showMoreBtn.onclick = () => {
                    isExpanded = !isExpanded;
                    hiddenDiv.classList.toggle('visible', isExpanded);
                    showMoreBtn.textContent = isExpanded ? 'Details ausblenden ‚ñ≤' : 'Alle Details anzeigen ‚ñº';
                };
                
                alert.appendChild(showMoreBtn);
                alert.appendChild(hiddenDiv);
            }
            
            // Korrektur-Sektion hinzuf√ºgen wenn Korrekturen verf√ºgbar sind
            if (options.showCorrections && alertData.corrections && alertData.corrections.length > 0) {
                const correctionSection = document.createElement('div');
                correctionSection.className = 'correction-section';
                
                const correctionTitle = document.createElement('div');
                correctionTitle.className = 'correction-title';
                correctionTitle.innerHTML = `üîß Automatische Korrekturen (${alertData.corrections.length})`;
                correctionSection.appendChild(correctionTitle);
                
                // Einzelne Korrekturen
                alertData.corrections.forEach((correction, index) => {
                    const correctionItem = document.createElement('div');
                    correctionItem.className = 'correction-item';
                    
                    const description = document.createElement('div');
                    description.className = 'correction-description';
                    
                    const severityIcon = correction.severity === 'high' ? 'üî¥' : 
                                        correction.severity === 'medium' ? 'üü†' : 'üü°';
                    description.textContent = `${severityIcon} ${correction.description}`;
                    
                    const correctionBtn = document.createElement('button');
                    correctionBtn.className = 'correction-btn';
                    correctionBtn.textContent = 'Anwenden';
                    correctionBtn.dataset.correctionId = index;
                    
                    let isApplied = false;
                    correctionBtn.onclick = () => {
                        if (!isApplied) {
                            try {
                                const result = correction.action();
                                correctionBtn.textContent = '‚úì Angewendet';
                                correctionBtn.classList.add('applied');
                                correctionBtn.disabled = true;
                                isApplied = true;
                                
                                // Kurze Best√§tigung anzeigen
                                const tempMsg = document.createElement('div');
                                tempMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(0,128,0,0.9); color: white; padding: 8px 12px; border-radius: 4px; z-index: 10001; font-size: 12px;';
                                tempMsg.textContent = result;
                                document.body.appendChild(tempMsg);
                                setTimeout(() => tempMsg.remove(), 3000);
                                
                                // Nach Korrektur System-Check erneut durchf√ºhren wenn gew√ºnscht
                                if (correction.severity === 'high') {
                                    setTimeout(() => {
                                        if (confirm('Wichtige Korrektur angewendet. System-Check erneut durchf√ºhren?')) {
                                            showCriticalSituations();
                                        }
                                    }, 1000);
                                }
                                
                            } catch (error) {
                                console.error('Korrektur-Fehler:', error);
                                correctionBtn.textContent = '‚ùå Fehler';
                                correctionBtn.style.backgroundColor = 'rgba(255,0,0,0.3)';
                            }
                        }
                    };
                    
                    correctionItem.appendChild(description);
                    correctionItem.appendChild(correctionBtn);
                    correctionSection.appendChild(correctionItem);
                });
                
                // Bulk-Aktionen
                if (alertData.corrections.length > 1) {
                    const bulkDiv = document.createElement('div');
                    bulkDiv.className = 'bulk-corrections';
                    
                    const applyAllBtn = document.createElement('button');
                    applyAllBtn.className = 'bulk-correction-btn';
                    applyAllBtn.textContent = 'Alle Korrekturen anwenden';
                    applyAllBtn.onclick = () => {
                        if (confirm(`Wirklich alle ${alertData.corrections.length} Korrekturen anwenden?`)) {
                            let appliedCount = 0;
                            let results = [];
                            
                            alertData.corrections.forEach((correction, index) => {
                                const btn = correctionSection.querySelector(`[data-correction-id="${index}"]`);
                                if (!btn.disabled) {
                                    try {
                                        const result = correction.action();
                                        btn.textContent = '‚úì Angewendet';
                                        btn.classList.add('applied');
                                        btn.disabled = true;
                                        appliedCount++;
                                        results.push(result);
                                    } catch (error) {
                                        btn.textContent = '‚ùå Fehler';
                                        btn.style.backgroundColor = 'rgba(255,0,0,0.3)';
                                    }
                                }
                            });
                            
                            applyAllBtn.textContent = `‚úì ${appliedCount} angewendet`;
                            applyAllBtn.disabled = true;
                            
                            // Sammle alle Ergebnisse
                            const tempMsg = document.createElement('div');
                            tempMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(0,128,0,0.9); color: white; padding: 12px; border-radius: 4px; z-index: 10001; font-size: 12px; max-width: 300px;';
                            tempMsg.innerHTML = `<strong>${appliedCount} Korrekturen angewendet:</strong><br>${results.join('<br>')}`;
                            document.body.appendChild(tempMsg);
                            setTimeout(() => tempMsg.remove(), 5000);
                        }
                    };
                    
                    bulkDiv.appendChild(applyAllBtn);
                    correctionSection.appendChild(bulkDiv);
                }
                
                alert.appendChild(correctionSection);
            }
            
            // Alert-Daten f√ºr Export speichern
            currentAlertData = {
                message: alertData.fullMessage,
                type,
                timestamp: new Date().toLocaleString('de-DE'),
                options
            };
            
            document.querySelector('.container').insertBefore(alert, document.querySelector('.tabs'));
            
            // Auto-Remove nur f√ºr nicht-persistente Alerts
            if (!isPersistent) {
                const displayTime = summaryMessage.length > 100 ? 8000 : 5000;
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.remove();
                    }
                }, displayTime);
            }
        }

        // Hilfsfunktion f√ºr robustes CSV-Lesen mit verschiedenen Kodierungen
        function readCSVFile(file, callback) {
            // Erste Versuche mit UTF-8
            const reader = new FileReader();
            reader.onload = function(e) {
                let text = e.target.result;
                
                // Pr√ºfe auf Encoding-Probleme (ersetzt ÔøΩ)
                if (text.includes('ÔøΩ') || text.includes('\ufffd')) {
                    console.log('UTF-8 fehlgeschlagen, versuche Windows-1252...');
                    // Versuche Windows-1252 (h√§ufig bei Excel)
                    const reader2 = new FileReader();
                    reader2.onload = function(e2) {
                        let text2 = e2.target.result;
                        if (text2.includes('ÔøΩ') || text2.includes('\ufffd')) {
                            console.log('Windows-1252 fehlgeschlagen, versuche ISO-8859-1...');
                            // Versuche ISO-8859-1
                            const reader3 = new FileReader();
                            reader3.onload = function(e3) {
                                callback(e3.target.result);
                            };
                            reader3.readAsText(file, 'ISO-8859-1');
                        } else {
                            callback(text2);
                        }
                    };
                    reader2.readAsText(file, 'windows-1252');
                } else {
                    callback(text);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        // CSV Import-Funktionen
        function importProductsCSV() {
            const file = document.getElementById('productsCSV').files[0];
            if (!file) {
                showAlert('Bitte eine Datei ausw√§hlen!', 'error');
                return;
            }
            
            readCSVFile(file, function(csv) {
                const lines = csv.split(/\r?\n/).filter(line => line.trim());
                const rawData = [];
                const allErrors = [];
                const allWarnings = [];
                let imported = 0;
                
                // Parse und sammle alle Daten
                lines.forEach((line, index) => {
                    line = line.trim();
                    if (line) {
                        const processLine = (dataLine, lineNumber) => {
                            const parts = dataLine.split(';').map(s => s.trim());
                            const [productNumber, productName, cost] = parts;
                            const normalizedCost = cost ? cost.replace(',', '.') : cost;
                            
                            rawData.push({
                                lineNumber,
                                productNumber,
                                productName,
                                cost: normalizedCost,
                                originalLine: dataLine
                            });
                        };
                        
                        // Spezielle Behandlung f√ºr Windows-Zeilenendings in den Daten selbst
                        if (line.includes('\r')) {
                            const subLines = line.split('\r').filter(l => l.trim());
                            subLines.forEach((subLine, subIndex) => {
                                processLine(subLine.trim(), `${index + 1}.${subIndex + 1}`);
                            });
                        } else {
                            processLine(line, index + 1);
                        }
                    }
                });
                
                // Duplikate pr√ºfen
                const duplicates = checkForDuplicates(rawData, 'productNumber');
                
                // Validiere und importiere Daten
                rawData.forEach((item) => {
                    const validation = validateProductData(item.productNumber, item.productName, item.cost);
                    
                    // Sammle Fehler und Warnungen mit Zeilennummer
                    validation.errors.forEach(error => {
                        allErrors.push(`Zeile ${item.lineNumber}: ${error}`);
                    });
                    validation.warnings.forEach(warning => {
                        allWarnings.push(`Zeile ${item.lineNumber}: ${warning}`);
                    });
                    
                    // Importiere nur wenn keine Fehler
                    if (validation.errors.length === 0) {
                        // Pr√ºfe auf bereits existierende Produktnummer
                        const isDuplicate = duplicates.some(dup => dup.key === item.productNumber);
                        
                        if (products[item.productNumber] && !isDuplicate) {
                            allWarnings.push(`Zeile ${item.lineNumber}: Produkt "${item.productNumber}" wird √ºberschrieben`);
                        }
                        
                        products[item.productNumber] = {
                            name: item.productName,
                            cost: parseFloat(item.cost) || 0
                        };
                        imported++;
                    }
                });
                
                saveData();
                updateProductSelects();
                renderTables();
                showValidationSummary(imported, allErrors, allWarnings, duplicates, file.name);
            });
        }

        function importBomsCSV() {
            const file = document.getElementById('bomsCSV').files[0];
            if (!file) {
                showAlert('Bitte eine Datei ausw√§hlen!', 'error');
                return;
            }
            
            readCSVFile(file, function(csv) {
                const lines = csv.split(/\r?\n/).filter(line => line.trim());
                const rawData = [];
                const allErrors = [];
                const allWarnings = [];
                let imported = 0;
                
                // Parse und sammle alle Daten
                lines.forEach((line, index) => {
                    line = line.trim();
                    if (line) {
                        const processLine = (dataLine, lineNumber) => {
                            const parts = dataLine.split(';').map(s => s.trim());
                            const [mainProduct, component, quantity] = parts;
                            
                            rawData.push({
                                lineNumber,
                                mainProduct,
                                component,
                                quantity,
                                originalLine: dataLine
                            });
                        };
                        
                        // Spezielle Behandlung f√ºr Windows-Zeilenendings
                        if (line.includes('\r')) {
                            const subLines = line.split('\r').filter(l => l.trim());
                            subLines.forEach((subLine, subIndex) => {
                                processLine(subLine.trim(), `${index + 1}.${subIndex + 1}`);
                            });
                        } else {
                            processLine(line, index + 1);
                        }
                    }
                });
                
                // Duplikate pr√ºfen (Kombinationsschl√ºssel mainProduct + component)
                const bomKeys = rawData.map(item => `${item.mainProduct}->${item.component}`);
                const duplicates = [];
                const seen = new Set();
                bomKeys.forEach((key, index) => {
                    if (key && key !== 'undefined->undefined' && seen.has(key)) {
                        duplicates.push({ key, line: rawData[index].lineNumber });
                    } else if (key && key !== 'undefined->undefined') {
                        seen.add(key);
                    }
                });
                
                // Validiere und importiere Daten
                rawData.forEach((item) => {
                    const validation = validateBOMData(item.mainProduct, item.component, item.quantity);
                    
                    // Sammle Fehler und Warnungen mit Zeilennummer
                    validation.errors.forEach(error => {
                        allErrors.push(`Zeile ${item.lineNumber}: ${error}`);
                    });
                    validation.warnings.forEach(warning => {
                        allWarnings.push(`Zeile ${item.lineNumber}: ${warning}`);
                    });
                    
                    // Importiere nur wenn keine Fehler
                    if (validation.errors.length === 0) {
                        if (!boms[item.mainProduct]) {
                            boms[item.mainProduct] = {};
                        }
                        
                        // Pr√ºfe auf √úberschreibung
                        if (boms[item.mainProduct][item.component]) {
                            allWarnings.push(`Zeile ${item.lineNumber}: Komponente "${item.component}" in "${item.mainProduct}" wird √ºberschrieben (alt: ${boms[item.mainProduct][item.component]}, neu: ${item.quantity})`);
                        }
                        
                        boms[item.mainProduct][item.component] = parseInt(item.quantity);
                        imported++;
                    }
                });
                
                saveData();
                renderBoms();
                showValidationSummary(imported, allErrors, allWarnings, duplicates, file.name);
            });
        }

        function importInventoryCSV() {
            const file = document.getElementById('inventoryCSV').files[0];
            if (!file) {
                showAlert('Bitte eine Datei ausw√§hlen!', 'error');
                return;
            }
            
            readCSVFile(file, function(csv) {
                const lines = csv.split(/\r?\n/).filter(line => line.trim());
                const rawData = [];
                const allErrors = [];
                const allWarnings = [];
                let imported = 0;
                
                // Parse und sammle alle Daten
                lines.forEach((line, index) => {
                    line = line.trim();
                    if (line) {
                        const processLine = (dataLine, lineNumber) => {
                            const parts = dataLine.split(';').map(s => s.trim());
                            const [productNumber, quantity] = parts;
                            
                            rawData.push({
                                lineNumber,
                                productNumber,
                                quantity,
                                originalLine: dataLine
                            });
                        };
                        
                        // Spezielle Behandlung f√ºr Windows-Zeilenendings
                        if (line.includes('\r')) {
                            const subLines = line.split('\r').filter(l => l.trim());
                            subLines.forEach((subLine, subIndex) => {
                                processLine(subLine.trim(), `${index + 1}.${subIndex + 1}`);
                            });
                        } else {
                            processLine(line, index + 1);
                        }
                    }
                });
                
                // Duplikate pr√ºfen
                const duplicates = checkForDuplicates(rawData, 'productNumber');
                
                // Validiere und importiere Daten
                rawData.forEach((item) => {
                    const validation = validateInventoryData(item.productNumber, item.quantity);
                    
                    // Sammle Fehler und Warnungen mit Zeilennummer
                    validation.errors.forEach(error => {
                        allErrors.push(`Zeile ${item.lineNumber}: ${error}`);
                    });
                    validation.warnings.forEach(warning => {
                        allWarnings.push(`Zeile ${item.lineNumber}: ${warning}`);
                    });
                    
                    // Importiere nur wenn keine Fehler
                    if (validation.errors.length === 0) {
                        // Pr√ºfe auf √úberschreibung
                        const isDuplicate = duplicates.some(dup => dup.key === item.productNumber);
                        if (inventory[item.productNumber] !== undefined && !isDuplicate) {
                            allWarnings.push(`Zeile ${item.lineNumber}: Lagerbestand f√ºr "${item.productNumber}" wird √ºberschrieben (alt: ${inventory[item.productNumber]}, neu: ${item.quantity || 0})`);
                        }
                        
                        inventory[item.productNumber] = parseInt(item.quantity) || 0;
                        imported++;
                    }
                });
                
                saveData();
                renderTables();
                showValidationSummary(imported, allErrors, allWarnings, duplicates, file.name);
            });
        }

        function importDemandCSV() {
            const file = document.getElementById('demandCSV').files[0];
            if (!file) {
                showAlert('Bitte eine Datei ausw√§hlen!', 'error');
                return;
            }
            
            readCSVFile(file, function(csv) {
                const lines = csv.split(/\r?\n/).filter(line => line.trim());
                const rawData = [];
                const allErrors = [];
                const allWarnings = [];
                let imported = 0;
                
                // Parse und sammle alle Daten
                lines.forEach((line, index) => {
                    line = line.trim();
                    if (line) {
                        const processLine = (dataLine, lineNumber) => {
                            const parts = dataLine.split(';').map(s => s.trim());
                            const [productNumber, quantity] = parts;
                            
                            rawData.push({
                                lineNumber,
                                productNumber,
                                quantity,
                                originalLine: dataLine
                            });
                        };
                        
                        // Spezielle Behandlung f√ºr Windows-Zeilenendings
                        if (line.includes('\r')) {
                            const subLines = line.split('\r').filter(l => l.trim());
                            subLines.forEach((subLine, subIndex) => {
                                processLine(subLine.trim(), `${index + 1}.${subIndex + 1}`);
                            });
                        } else {
                            processLine(line, index + 1);
                        }
                    }
                });
                
                // Duplikate sammeln (aber nicht als Fehler, da Bedarfe summiert werden)
                const duplicates = checkForDuplicates(rawData, 'productNumber');
                if (duplicates.length > 0) {
                    allWarnings.push(`Mehrfache Bedarfseintr√§ge werden summiert: ${duplicates.map(d => d.key).join(', ')}`);
                }
                
                // Validiere und importiere Daten
                rawData.forEach((item) => {
                    const validation = validateInventoryData(item.productNumber, item.quantity); // Gleiche Validierung wie Inventory
                    
                    // Sammle Fehler und Warnungen mit Zeilennummer
                    validation.errors.forEach(error => {
                        allErrors.push(`Zeile ${item.lineNumber}: ${error}`);
                    });
                    validation.warnings.forEach(warning => {
                        allWarnings.push(`Zeile ${item.lineNumber}: ${warning}`);
                    });
                    
                    // Importiere nur wenn keine Fehler (addiere zum bestehenden Bedarf)
                    if (validation.errors.length === 0) {
                        const quantityToAdd = parseInt(item.quantity) || 0;
                        if (quantityToAdd > 0) {
                            demand[item.productNumber] = (demand[item.productNumber] || 0) + quantityToAdd;
                            imported++;
                        }
                    }
                });
                
                saveData();
                renderTables();
                showValidationSummary(imported, allErrors, allWarnings, [], file.name); // Keine Duplikate als Fehler
            });
        }

        // ERP-konforme Bedarfsermittlung
        function calculateRequirements() {
            console.log('=== Starte ERP-konforme Bedarfsermittlung ===');
            
            // Datenstrukturen f√ºr MRP-Lauf
            const netRequirements = {}; // Nettobedarf pro Ebene
            const plannedOrders = {};   // Geplante Auftr√§ge/Bestellungen
            const purchaseParts = {};   // Einkaufsteile
            const manufactureParts = {}; // Fertigungsteile
            
            // 1. Schritt: Berechne Produktebenen (Low-Level-Codes)
            function calculateProductLevels() {
                const levels = {};
                const visited = new Set();
                
                function calculateLevel(productNumber, currentPath = []) {
                    if (currentPath.includes(productNumber)) {
                        console.warn(`Zyklus erkannt: ${currentPath.join(' -> ')} -> ${productNumber}`);
                        return 0;
                    }
                    
                    if (levels[productNumber] !== undefined) {
                        return levels[productNumber];
                    }
                    
                    if (!boms[productNumber]) {
                        // Einkaufsteil (niedrigste Ebene)
                        levels[productNumber] = 0;
                        // Debug f√ºr kritische Artikel
                        if (['100041', '101048', '100068', '900285', '900286'].includes(productNumber)) {
                            console.log(`*** EBENEN-DEBUG ${productNumber}: Einkaufsteil, Ebene = 0 ***`);
                        }
                        return 0;
                    }
                    
                    let maxLevel = 0;
                    const newPath = [...currentPath, productNumber];
                    
                    // Debug f√ºr kritische Artikel
                    if (['100041', '101048', '100068', '900285', '900286'].includes(productNumber)) {
                        console.log(`*** EBENEN-DEBUG ${productNumber}: Hat St√ºckliste, pr√ºfe Komponenten ***`);
                        console.log(`    Komponenten:`, Object.keys(boms[productNumber]));
                    }
                    
                    Object.keys(boms[productNumber]).forEach(component => {
                        const componentLevel = calculateLevel(component, newPath);
                        maxLevel = Math.max(maxLevel, componentLevel + 1);
                        
                        // Debug f√ºr kritische Artikel
                        if (['100041', '101048', '100068', '900285', '900286'].includes(productNumber)) {
                            console.log(`    ${component}: Ebene ${componentLevel}, maxLevel jetzt ${maxLevel}`);
                        }
                    });
                    
                    levels[productNumber] = maxLevel;
                    
                    // Debug f√ºr kritische Artikel
                    if (['100041', '101048', '100068', '900285', '900286'].includes(productNumber)) {
                        console.log(`*** EBENEN-DEBUG ${productNumber}: Finale Ebene = ${maxLevel} ***`);
                    }
                    
                    return maxLevel;
                }
                
                // Berechne Ebenen f√ºr alle Produkte
                Object.keys(products).forEach(productNumber => {
                    calculateLevel(productNumber);
                });
                
                console.log('Produktebenen:', levels);
                return levels;
            }
            
            // 2. Schritt: Sortiere Produkte nach Ebenen (niedrigste zuerst)
            const productLevels = calculateProductLevels();
            const sortedProducts = Object.keys(productLevels)
                .sort((a, b) => productLevels[a] - productLevels[b]);
            
            console.log('Sortierte Produkte (nach Ebenen):', sortedProducts);
            
            // 3. Schritt: Initialer Prim√§rbedarf
            console.log('\\n=== Prim√§rbedarf ===');
            Object.keys(demand).forEach(productNumber => {
                const quantity = demand[productNumber];
                netRequirements[productNumber] = (netRequirements[productNumber] || 0) + quantity;
                console.log(`Prim√§rbedarf: ${productNumber} = ${quantity}`);
                
                // Spezielle Debug-Ausgabe f√ºr 100892, 100041, 900286, 900285
                if (productNumber === '100892') {
                    console.log(`*** DEBUG 100892: Prim√§rbedarf gesetzt auf ${quantity} ***`);
                }
                if (productNumber === '100041') {
                    console.log(`*** DEBUG 100041: Prim√§rbedarf gesetzt auf ${quantity} ***`);
                }
                if (productNumber === '900286') {
                    console.log(`*** DEBUG 900286: Prim√§rbedarf gesetzt auf ${quantity} ***`);
                }
                if (productNumber === '900285') {
                    console.log(`*** DEBUG 900285: Prim√§rbedarf gesetzt auf ${quantity} ***`);
                }
            });
            
            // 4. Schritt: Iterative MRP-Verarbeitung
            console.log('\\n=== Iterative MRP-Verarbeitung ===');
            
            let iteration = 0;
            let hasChanges = true;
            const maxIterations = 20; // Schutz vor Endlosschleifen
            
            while (hasChanges && iteration < maxIterations) {
                iteration++;
                hasChanges = false;
                console.log(`\\n=== Iteration ${iteration} ===`);
                
                // Erstelle Kopie der aktuellen Nettoanforderungen f√ºr Vergleich
                const previousNetRequirements = { ...netRequirements };
                
                for (let level = 0; level <= Math.max(...Object.values(productLevels)); level++) {
                    console.log(`\\n--- Ebene ${level} ---`);
                    
                    const productsAtLevel = sortedProducts.filter(p => productLevels[p] === level);
                    
                    productsAtLevel.forEach(productNumber => {
                        const grossRequirement = netRequirements[productNumber] || 0;
                        
                        // Debug f√ºr relevante Artikel - auch wenn kein Bedarf
                        if (['100041', '900286', '900285', '101048'].includes(productNumber)) {
                            console.log(`*** DEBUG ${productNumber}: Pr√ºfung in Ebene ${level} (Iteration ${iteration}) ***`);
                            console.log(`    Bruttobedarf: ${grossRequirement}`);
                            console.log(`    Wird verarbeitet: ${grossRequirement > 0 ? 'Ja' : 'Nein'}`);
                        }
                        
                        if (grossRequirement <= 0) return;
                        
                        // Pr√ºfe, ob dieser Artikel bereits in einer vorherigen Iteration verarbeitet wurde
                        if (plannedOrders[productNumber] && iteration > 1) {
                            // Artikel bereits verarbeitet, √ºberspringe
                            return;
                        }
                        
                        console.log(`\\nVerarbeite: ${productNumber} (Ebene ${level}, Iteration ${iteration})`);
                        console.log(`  Bruttobedarf: ${grossRequirement}`);
                        
                        // Spezielle Debug-Ausgabe f√ºr relevante Artikel
                        if (['100892', '100041', '900286', '900285', '101048'].includes(productNumber)) {
                            console.log(`*** DEBUG ${productNumber}: Wird in Ebene ${level} verarbeitet (Iteration ${iteration}) ***`);
                            console.log(`    Bruttobedarf: ${grossRequirement}`);
                            console.log(`    Lagerbestand: ${inventory[productNumber] || 0}`);
                            console.log(`    Hat St√ºckliste: ${boms[productNumber] ? 'Ja' : 'Nein'}`);
                            if (boms[productNumber]) {
                                console.log(`    St√ºckliste:`, boms[productNumber]);
                            }
                        }
                        
                        // Verf√ºgbarer Lagerbestand
                        const availableStock = inventory[productNumber] || 0;
                        console.log(`  Lagerbestand: ${availableStock}`);
                        
                        // Nettobedarf berechnen
                        const netRequirement = Math.max(0, grossRequirement - availableStock);
                        console.log(`  Nettobedarf: ${netRequirement}`);
                        
                        if (netRequirement > 0) {
                            // Geplante Bestellung/Fertigung
                            plannedOrders[productNumber] = netRequirement;
                            
                            if (boms[productNumber]) {
                                // Fertigungsteil - Sekund√§rbedarf generieren
                                manufactureParts[productNumber] = netRequirement;
                                console.log(`  -> Fertigungsauftrag: ${netRequirement}`);
                                console.log(`  -> Generiere Sekund√§rbedarf:`);
                                
                                Object.keys(boms[productNumber]).forEach(component => {
                                    const componentQuantity = boms[productNumber][component] * netRequirement;
                                    const previousTotal = netRequirements[component] || 0;
                                    netRequirements[component] = previousTotal + componentQuantity;
                                    console.log(`    ${component}: +${componentQuantity} (total: ${netRequirements[component]})`);
                                    
                                    // Markiere √Ñnderung wenn neuer Bedarf entstanden ist
                                    if (componentQuantity > 0) {
                                        hasChanges = true;
                                    }
                                    
                                    // Debug wenn 900286 oder 900285 Komponenten generieren
                                    if (['900286', '900285'].includes(productNumber)) {
                                        console.log(`*** DEBUG ${productNumber}: Generiert Sekund√§rbedarf f√ºr ${component} ***`);
                                        console.log(`    St√ºcklistenmenge: ${boms[productNumber][component]}`);
                                        console.log(`    Fertigungsauftrag: ${netRequirement}`);
                                        console.log(`    Bedarf f√ºr ${component}: ${componentQuantity}`);
                                        console.log(`    Vorheriger Gesamtbedarf: ${previousTotal}`);
                                        console.log(`    Neuer Gesamtbedarf: ${netRequirements[component]}`);
                                    }
                                    
                                    // Spezielle Debug-Ausgabe f√ºr 100892 und 100041
                                    if (component === '100892') {
                                        console.log(`*** DEBUG 100892: Wird von ${productNumber} ben√∂tigt ***`);
                                        console.log(`    St√ºcklistenmenge: ${boms[productNumber][component]}`);
                                        console.log(`    Fertigungsauftrag: ${netRequirement}`);
                                        console.log(`    Bedarf f√ºr 100892: ${componentQuantity}`);
                                        console.log(`    Vorheriger Gesamtbedarf: ${previousTotal}`);
                                        console.log(`    Neuer Gesamtbedarf: ${netRequirements[component]}`);
                                    }
                                    if (component === '100041') {
                                        console.log(`*** DEBUG 100041: Wird von ${productNumber} ben√∂tigt ***`);
                                        console.log(`    St√ºcklistenmenge: ${boms[productNumber][component]}`);
                                        console.log(`    Fertigungsauftrag: ${netRequirement}`);
                                        console.log(`    Bedarf f√ºr 100041: ${componentQuantity}`);
                                        console.log(`    Vorheriger Gesamtbedarf: ${previousTotal}`);
                                        console.log(`    Neuer Gesamtbedarf: ${netRequirements[component]}`);
                                    }
                                });
                            } else {
                                // Einkaufsteil
                                purchaseParts[productNumber] = netRequirement;
                                console.log(`  -> Bestellvorschlag: ${netRequirement}`);
                            }
                        } else {
                            console.log(`  -> Kein Bedarf (durch Lager gedeckt)`);
                        }
                    });
                }
                
                console.log(`\\n=== Ende Iteration ${iteration} ===`);
                console.log(`√Ñnderungen in dieser Iteration: ${hasChanges ? 'Ja' : 'Nein'}`);
            }
            
            if (iteration >= maxIterations) {
                console.warn(`Warnung: Maximale Anzahl Iterationen (${maxIterations}) erreicht!`);
            } else {
                console.log(`\\nMRP-Lauf nach ${iteration} Iteration(en) abgeschlossen.`);
            }
            
            // 5. Schritt: Ergebnisse zusammenstellen
            console.log('\\n=== Endergebnisse ===');
            console.log('Geplante Auftr√§ge:', plannedOrders);
            console.log('Einkaufsteile:', purchaseParts);
            console.log('Fertigungsteile:', manufactureParts);
            console.log('Alle Nettoanforderungen:', netRequirements);
            
            const finalRequirements = {};
            
            // WICHTIG: Verwende plannedOrders (nicht netRequirements) f√ºr finale Darstellung
            // Das sind die tats√§chlich zu beschaffenden/fertigenden Mengen
            Object.keys(plannedOrders).forEach(productNumber => {
                const needed = plannedOrders[productNumber];
                const available = inventory[productNumber] || 0;
                const grossRequirement = netRequirements[productNumber] || needed;
                
                if (needed > 0) {
                    finalRequirements[productNumber] = {
                        required: grossRequirement,
                        available: available,
                        needed: needed,
                        cost: products[productNumber] ? (products[productNumber].cost || 0) * needed : 0,
                        level: productLevels[productNumber] || 0
                    };
                }
            });
            
            // Zus√§tzlich: Pr√ºfe ob es Nettoanforderungen gibt, die nicht in plannedOrders stehen
            // (Kann bei Komponenten passieren, die nur als Sekund√§rbedarf ben√∂tigt werden)
            Object.keys(netRequirements).forEach(productNumber => {
                if (!plannedOrders[productNumber] && netRequirements[productNumber] > 0) {
                    const available = inventory[productNumber] || 0;
                    const grossRequirement = netRequirements[productNumber];
                    const needed = Math.max(0, grossRequirement - available);
                    
                    if (needed > 0) {
                        console.log(`Zus√§tzlicher Bedarf gefunden: ${productNumber} = ${needed}`);
                        
                        finalRequirements[productNumber] = {
                            required: grossRequirement,
                            available: available,
                            needed: needed,
                            cost: products[productNumber] ? (products[productNumber].cost || 0) * needed : 0,
                            level: productLevels[productNumber] || 0
                        };
                        
                        // Klassifiziere als Einkaufs- oder Fertigungsteil
                        if (boms[productNumber]) {
                            manufactureParts[productNumber] = needed;
                        } else {
                            purchaseParts[productNumber] = needed;
                        }
                    }
                }
            });
            
            console.log('\\n=== Finale Requirements ===');
            console.log('Final Requirements:', finalRequirements);
            console.log('Finale Einkaufsteile:', purchaseParts);
            console.log('Finale Fertigungsteile:', manufactureParts);
            
            displayRequirements(finalRequirements, purchaseParts, manufactureParts);
        }

        let currentFilter = 'all'; // Global f√ºr Filter-Status
        
        function displayRequirements(requirements, purchaseParts, manufactureParts) {
            const resultDiv = document.getElementById('requirementsResult');
            
            if (Object.keys(requirements).length === 0) {
                resultDiv.innerHTML = '<div class="alert success">Kein zus√§tzlicher Materialbedarf erforderlich!</div>';
                return;
            }
            
            // Separate Einkaufsteile und Fertigungsteile
            const purchaseRequirements = {};
            const manufactureRequirements = {};
            
            Object.keys(requirements).forEach(productNumber => {
                if (purchaseParts[productNumber]) {
                    purchaseRequirements[productNumber] = requirements[productNumber];
                } else if (manufactureParts[productNumber]) {
                    manufactureRequirements[productNumber] = requirements[productNumber];
                }
            });
            
            // Gesamtkosten berechnen
            const purchaseCost = Object.keys(purchaseRequirements).reduce((sum, key) => 
                sum + (purchaseRequirements[key].cost || 0), 0);
            const manufactureCost = Object.keys(manufactureRequirements).reduce((sum, key) => 
                sum + (manufactureRequirements[key].cost || 0), 0);
            const totalCost = purchaseCost + manufactureCost;
            
            let html = '<div class="requirements-result">';
            
            // Kosten√ºbersicht oben
            html += `<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: white;">üí∞ Kosten√ºbersicht Materialbedarf</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: bold;">${purchaseCost.toFixed(2)} ‚Ç¨</div>
                        <div style="opacity: 0.9;">üõí Einkaufskosten</div>
                        <div style="opacity: 0.7;">${Object.keys(purchaseRequirements).length} Artikel</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: bold;">${manufactureCost.toFixed(2)} ‚Ç¨</div>
                        <div style="opacity: 0.9;">üè≠ Fertigungskosten</div>
                        <div style="opacity: 0.7;">${Object.keys(manufactureRequirements).length} Artikel</div>
                    </div>
                    <div style="text-align: center; border-left: 2px solid rgba(255,255,255,0.3); padding-left: 15px;">
                        <div style="font-size: 28px; font-weight: bold;">${totalCost.toFixed(2)} ‚Ç¨</div>
                        <div style="opacity: 0.9;">üíé Gesamtkosten</div>
                        <div style="opacity: 0.7;">${Object.keys(requirements).length} Artikel total</div>
                    </div>
                </div>
            </div>`;
            
            // Pr√ºfe Artikel ohne Kosten
            const noCostItems = Object.keys(requirements).filter(key => 
                !products[key] || (products[key].cost || 0) === 0);
            
            // Filter-Buttons
            html += `<div style="margin-bottom: 20px; text-align: center;">
                <div style="margin-bottom: 10px;">
                    <button onclick="filterRequirements('all')" class="${currentFilter === 'all' ? 'success' : ''}" 
                            style="margin-right: 10px;">üîç Alle anzeigen (${Object.keys(requirements).length})</button>
                    <button onclick="filterRequirements('purchase')" class="${currentFilter === 'purchase' ? 'success' : ''}" 
                            style="margin-right: 10px;">üõí Nur Einkauf (${Object.keys(purchaseRequirements).length})</button>
                    <button onclick="filterRequirements('manufacture')" class="${currentFilter === 'manufacture' ? 'success' : ''}" 
                            style="margin-right: 10px;">üè≠ Nur Fertigung (${Object.keys(manufactureRequirements).length})</button>
                    <button onclick="filterRequirements('nocost')" class="${currentFilter === 'nocost' ? 'success' : ''}" 
                            style="margin-right: 10px; ${noCostItems.length > 0 ? 'background-color: #f39c12; color: white;' : ''}">
                            ‚ö†Ô∏è Ohne Kosten (${noCostItems.length})</button>
                </div>
                <div>
                    <button onclick="exportRequirementsCSV()" style="background-color: #27ae60; color: white; margin-right: 10px;">
                            üìä CSV Export</button>
                    <button onclick="exportRequirementsPDF()" style="background-color: #8e44ad; color: white;">
                            üìÑ PDF Export</button>
                </div>
            </div>`;
            
            // Container f√ºr gefilterte Inhalte
            html += '<div id="filteredRequirements"></div>';
            
            html += '</div></div>'; // Schlie√üe filteredRequirements und requirements-result
            
            // Speichere Daten f√ºr Filterung
            window.requirementsData = {
                requirements,
                purchaseRequirements,
                manufactureRequirements
            };
            
            resultDiv.innerHTML = html;
            
            // Initial alle anzeigen
            filterRequirements('all');
        }

        // Filter-Funktionen f√ºr Bedarfsermittlung
        function filterRequirements(filterType) {
            currentFilter = filterType;
            
            if (!window.requirementsData) return;
            
            const { requirements, purchaseRequirements, manufactureRequirements } = window.requirementsData;
            const container = document.getElementById('filteredRequirements');
            
            if (!container) return;
            
            // Erstelle purchaseParts und manufactureParts aus den requirementsData
            const purchaseParts = {};
            const manufactureParts = {};
            
            Object.keys(purchaseRequirements).forEach(key => {
                purchaseParts[key] = purchaseRequirements[key].needed;
            });
            
            Object.keys(manufactureRequirements).forEach(key => {
                manufactureParts[key] = manufactureRequirements[key].needed;
            });
            
            let html = '';
            
            // Button-Status aktualisieren
            document.querySelectorAll('#requirementsResult button').forEach(btn => {
                btn.classList.remove('success');
            });
            
            // Filter-Logik
            let itemsToShow = {};
            
            if (filterType === 'nocost' || filterType.startsWith('nocost-')) {
                // Alle Artikel ohne Kosten
                Object.keys(requirements).forEach(key => {
                    if (!products[key] || (products[key].cost || 0) === 0) {
                        itemsToShow[key] = requirements[key];
                    }
                });
                
                // Unterteile nach Einkauf/Fertigung
                const noCostPurchase = {};
                const noCostManufacture = {};
                
                Object.keys(itemsToShow).forEach(key => {
                    if (purchaseParts[key]) {
                        noCostPurchase[key] = itemsToShow[key];
                    } else if (manufactureParts[key]) {
                        noCostManufacture[key] = itemsToShow[key];
                    }
                });
                
                html += '<h4 style="color: #f39c12; margin-top: 20px;">‚ö†Ô∏è Artikel ohne Kostens√§tze:</h4>';
                
                // Zus√§tzliche Sub-Filter f√ºr "Ohne Kosten"
                html += `<div style="margin-bottom: 15px; text-align: center;">
                    <button onclick="filterRequirements('nocost-all')" class="${currentFilter === 'nocost-all' || currentFilter === 'nocost' ? 'success' : ''}" 
                            style="margin-right: 10px; font-size: 12px; padding: 5px 10px;">üîç Alle (${Object.keys(itemsToShow).length})</button>
                    <button onclick="filterRequirements('nocost-purchase')" class="${currentFilter === 'nocost-purchase' ? 'success' : ''}" 
                            style="margin-right: 10px; font-size: 12px; padding: 5px 10px;">üõí Nur Einkauf (${Object.keys(noCostPurchase).length})</button>
                    <button onclick="filterRequirements('nocost-manufacture')" class="${currentFilter === 'nocost-manufacture' ? 'success' : ''}" 
                            style="font-size: 12px; padding: 5px 10px;">üè≠ Nur Fertigung (${Object.keys(noCostManufacture).length})</button>
                </div>`;
                
                // Bestimme welche Items angezeigt werden sollen basierend auf dem aktuellen Filter
                let displayItems = itemsToShow; // Standard: alle ohne Kosten
                
                if (currentFilter === 'nocost-purchase') {
                    displayItems = noCostPurchase;
                } else if (currentFilter === 'nocost-manufacture') {
                    displayItems = noCostManufacture;
                } else if (currentFilter === 'nocost' || currentFilter === 'nocost-all') {
                    displayItems = itemsToShow; // Alle ohne Kosten
                }
                
                html += '<table style="margin-bottom: 20px;"><thead><tr><th>Typ</th><th>Ebene</th><th>Produktnummer</th><th>Artikelname</th><th>Ben√∂tigt</th><th>Verf√ºgbar</th><th>Zu beschaffen</th><th>Kosten (‚Ç¨)</th><th>Aktionen</th></tr></thead><tbody>';
                
                Object.keys(displayItems).forEach(productNumber => {
                    const req = displayItems[productNumber];
                    const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                    const currentCost = products[productNumber] ? (products[productNumber].cost || 0) : 0;
                    const itemType = purchaseParts[productNumber] ? 'üõí Einkauf' : 'üè≠ Fertigung';
                    const bgColor = purchaseParts[productNumber] ? '#ffebee' : '#e3f2fd';
                    
                    html += `<tr style="background-color: ${bgColor};">
                        <td>${itemType}</td>
                        <td>${req.level || 0}</td>
                        <td>${productNumber}</td>
                        <td>${productName}</td>
                        <td>${req.required}</td>
                        <td>${req.available}</td>
                        <td><strong>${req.needed}</strong></td>
                        <td><input type="number" step="0.01" value="${currentCost}" style="width: 80px;" 
                             onchange="updateProductCost('${productNumber}', this.value)" /></td>
                        <td><button onclick="updateProductCost('${productNumber}', document.querySelector('input[onchange*=\\\'${productNumber}\\\']').value)" 
                             style="padding: 5px 10px; font-size: 12px;">üíæ Speichern</button></td>
                    </tr>`;
                });
                
                html += '</tbody></table>';
            } else if (filterType === 'all' || filterType === 'purchase') {
                // Einkaufsteile anzeigen
                if (Object.keys(purchaseRequirements).length > 0) {
                    html += '<h4 style="color: #e74c3c; margin-top: 20px;">üõí Einkaufsteile (zu bestellen):</h4>';
                    html += '<table style="margin-bottom: 20px;"><thead><tr><th>Ebene</th><th>Produktnummer</th><th>Artikelname</th><th>Ben√∂tigt</th><th>Verf√ºgbar</th><th>Zu bestellen</th><th>Kosten (‚Ç¨)</th></tr></thead><tbody>';
                    
                    // Sortiere nach Ebenen
                    const sortedPurchase = Object.keys(purchaseRequirements)
                        .sort((a, b) => (purchaseRequirements[a].level || 0) - (purchaseRequirements[b].level || 0));
                    
                    sortedPurchase.forEach(productNumber => {
                        const req = purchaseRequirements[productNumber];
                        const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                        
                        html += `<tr style="background-color: #ffebee;">
                            <td>${req.level || 0}</td>
                            <td>${productNumber}</td>
                            <td>${productName}</td>
                            <td>${req.required}</td>
                            <td>${req.available}</td>
                            <td><strong>${req.needed}</strong></td>
                            <td><strong>${(req.cost || 0).toFixed(2)}</strong></td>
                        </tr>`;
                    });
                    
                    html += `</tbody></table>`;
                }
            }
            
            if (filterType === 'all' || filterType === 'manufacture') {
                // Fertigungsteile anzeigen
                if (Object.keys(manufactureRequirements).length > 0) {
                    html += '<h4 style="color: #2980b9; margin-top: 20px;">üè≠ Fertigungsteile (zu produzieren):</h4>';
                    html += '<table style="margin-bottom: 20px;"><thead><tr><th>Ebene</th><th>Produktnummer</th><th>Artikelname</th><th>Ben√∂tigt</th><th>Verf√ºgbar</th><th>Zu fertigen</th><th>Kosten (‚Ç¨)</th></tr></thead><tbody>';
                    
                    // Sortiere nach Ebenen (h√∂chste zuerst f√ºr Fertigung)
                    const sortedManufacture = Object.keys(manufactureRequirements)
                        .sort((a, b) => (manufactureRequirements[b].level || 0) - (manufactureRequirements[a].level || 0));
                    
                    sortedManufacture.forEach(productNumber => {
                        const req = manufactureRequirements[productNumber];
                        const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                        
                        html += `<tr style="background-color: #e3f2fd;">
                            <td>${req.level || 0}</td>
                            <td>${productNumber}</td>
                            <td>${productName}</td>
                            <td>${req.required}</td>
                            <td>${req.available}</td>
                            <td><strong>${req.needed}</strong></td>
                            <td><strong>${(req.cost || 0).toFixed(2)}</strong></td>
                        </tr>`;
                    });
                    
                    html += `</tbody></table>`;
                }
            }
            
            if (html === '') {
                html = '<p style="text-align: center; color: #666; margin: 40px 0;">Keine Daten f√ºr den ausgew√§hlten Filter.</p>';
            }
            
            container.innerHTML = html;
            
            // Button-Highlight aktualisieren
            const activeButton = document.querySelector(`#requirementsResult button[onclick="filterRequirements('${filterType}')"]`);
            if (activeButton) {
                activeButton.classList.add('success');
            }
            
            // Spezielle Behandlung f√ºr nocost Sub-Filter
            if (filterType.startsWith('nocost')) {
                // Haupt-nocost Button auch hervorheben
                const mainNoCostButton = document.querySelector(`#requirementsResult button[onclick="filterRequirements('nocost')"]`);
                if (mainNoCostButton) {
                    mainNoCostButton.classList.add('success');
                }
            }
        }
        
        // Produktkosten direkt in Bedarfsermittlung aktualisieren
        function updateProductCost(productNumber, newCost) {
            const cost = parseFloat(newCost) || 0;
            
            if (!products[productNumber]) {
                showAlert(`Produkt ${productNumber} nicht gefunden!`, 'error');
                return;
            }
            
            products[productNumber].cost = cost;
            saveData();
            showAlert(`Kosten f√ºr ${productNumber} auf ${cost.toFixed(2)} ‚Ç¨ aktualisiert!`, 'success');
            
            // Bedarfsermittlung neu berechnen um aktualisierte Kosten zu zeigen
            calculateRequirements();
        }
        
        // CSV Export der Bedarfsermittlung
        function exportRequirementsCSV() {
            if (!window.requirementsData) {
                showAlert('Keine Bedarfsermittlung verf√ºgbar!', 'error');
                return;
            }
            
            const { requirements, purchaseRequirements, manufactureRequirements } = window.requirementsData;
            
            let csvContent = 'Typ;Ebene;Produktnummer;Artikelname;Ben√∂tigt;Verf√ºgbar;Zu beschaffen;Kosten pro Einheit;Gesamtkosten\n';
            
            // Einkaufsteile
            Object.keys(purchaseRequirements).forEach(productNumber => {
                const req = purchaseRequirements[productNumber];
                const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                const unitCost = products[productNumber] ? (products[productNumber].cost || 0) : 0;
                
                csvContent += `Einkauf;${req.level || 0};${productNumber};${productName};${req.required};${req.available};${req.needed};${unitCost.toFixed(2)};${(req.cost || 0).toFixed(2)}\n`;
            });
            
            // Fertigungsteile
            Object.keys(manufactureRequirements).forEach(productNumber => {
                const req = manufactureRequirements[productNumber];
                const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                const unitCost = products[productNumber] ? (products[productNumber].cost || 0) : 0;
                
                csvContent += `Fertigung;${req.level || 0};${productNumber};${productName};${req.required};${req.available};${req.needed};${unitCost.toFixed(2)};${(req.cost || 0).toFixed(2)}\n`;
            });
            
            // Download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `Bedarfsermittlung_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            
            showAlert('CSV-Export erfolgreich heruntergeladen!', 'success');
        }
        
        // PDF Export der Bedarfsermittlung
        function exportRequirementsPDF() {
            if (!window.requirementsData) {
                showAlert('Keine Bedarfsermittlung verf√ºgbar!', 'error');
                return;
            }
            
            // Vereinfachter PDF-Export als HTML-Print
            const { requirements, purchaseRequirements, manufactureRequirements } = window.requirementsData;
            
            // Berechne Kosten
            const purchaseCost = Object.keys(purchaseRequirements).reduce((sum, key) => 
                sum + (purchaseRequirements[key].cost || 0), 0);
            const manufactureCost = Object.keys(manufactureRequirements).reduce((sum, key) => 
                sum + (manufactureRequirements[key].cost || 0), 0);
            const totalCost = purchaseCost + manufactureCost;
            
            const printWindow = window.open('', '_blank');
            let printContent = `
                <html>
                <head>
                    <title>Bedarfsermittlung ${new Date().toLocaleDateString()}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1, h2 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f8f9fa; }
                        .summary { background-color: #e8f5e8; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
                        .purchase-row { background-color: #ffebee; }
                        .manufacture-row { background-color: #e3f2fd; }
                    </style>
                </head>
                <body>
                    <h1>Bedarfsermittlung vom ${new Date().toLocaleDateString()}</h1>
                    <div class="summary">
                        <h2>Kosten√ºbersicht</h2>
                        <p><strong>Einkaufskosten:</strong> ${purchaseCost.toFixed(2)} ‚Ç¨ (${Object.keys(purchaseRequirements).length} Artikel)</p>
                        <p><strong>Fertigungskosten:</strong> ${manufactureCost.toFixed(2)} ‚Ç¨ (${Object.keys(manufactureRequirements).length} Artikel)</p>
                        <p><strong>Gesamtkosten:</strong> ${totalCost.toFixed(2)} ‚Ç¨ (${Object.keys(requirements).length} Artikel total)</p>
                    </div>`;
                    
            if (Object.keys(purchaseRequirements).length > 0) {
                printContent += '<h2>üõí Einkaufsteile</h2><table><thead><tr><th>Ebene</th><th>Produktnummer</th><th>Artikelname</th><th>Ben√∂tigt</th><th>Verf√ºgbar</th><th>Zu bestellen</th><th>Kosten (‚Ç¨)</th></tr></thead><tbody>';
                
                Object.keys(purchaseRequirements).forEach(productNumber => {
                    const req = purchaseRequirements[productNumber];
                    const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                    
                    printContent += `<tr class="purchase-row">
                        <td>${req.level || 0}</td>
                        <td>${productNumber}</td>
                        <td>${productName}</td>
                        <td>${req.required}</td>
                        <td>${req.available}</td>
                        <td><strong>${req.needed}</strong></td>
                        <td><strong>${(req.cost || 0).toFixed(2)}</strong></td>
                    </tr>`;
                });
                
                printContent += '</tbody></table>';
            }
            
            if (Object.keys(manufactureRequirements).length > 0) {
                printContent += '<h2>üè≠ Fertigungsteile</h2><table><thead><tr><th>Ebene</th><th>Produktnummer</th><th>Artikelname</th><th>Ben√∂tigt</th><th>Verf√ºgbar</th><th>Zu fertigen</th><th>Kosten (‚Ç¨)</th></tr></thead><tbody>';
                
                Object.keys(manufactureRequirements).forEach(productNumber => {
                    const req = manufactureRequirements[productNumber];
                    const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                    
                    printContent += `<tr class="manufacture-row">
                        <td>${req.level || 0}</td>
                        <td>${productNumber}</td>
                        <td>${productName}</td>
                        <td>${req.required}</td>
                        <td>${req.available}</td>
                        <td><strong>${req.needed}</strong></td>
                        <td><strong>${(req.cost || 0).toFixed(2)}</strong></td>
                    </tr>`;
                });
                
                printContent += '</tbody></table>';
            }
            
            printContent += '</body></html>';
            
            printWindow.document.write(printContent);
            printWindow.document.close();
            printWindow.print();
            
            showAlert('PDF-Export wird vorbereitet...', 'success');
        }

        // UI-Hilfsfunktionen
        function updateProductSelects() {
            const selects = ['bomProduct', 'inventoryProduct'];
            
            // Normale Select-Dropdowns aktualisieren
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '<option value="">Produkt w√§hlen...</option>';
                    
                    Object.keys(products).forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `${key} - ${products[key].name}`;
                        select.appendChild(option);
                    });
                }
            });
            
            // Spezielle Behandlung f√ºr die durchsuchbare Bedarf-Datalist
            updateDemandProductList();
        }
        
        function updateDemandProductList(searchTerm = '') {
            const datalist = document.getElementById('demandProductList');
            if (datalist) {
                datalist.innerHTML = '';
                
                const filteredProducts = Object.keys(products).filter(key => {
                    const product = products[key];
                    if (!searchTerm) return true;
                    
                    return key.toLowerCase().includes(searchTerm) || 
                           product.name.toLowerCase().includes(searchTerm);
                });
                
                // Limitiere auf maximal 50 Ergebnisse f√ºr Performance
                filteredProducts.slice(0, 50).forEach(key => {
                    const product = products[key];
                    
                    // Option f√ºr Produktnummer - Name
                    const optionByNumber = document.createElement('option');
                    optionByNumber.value = key;
                    optionByNumber.textContent = `${key} - ${product.name}`;
                    datalist.appendChild(optionByNumber);
                    
                    // Option f√ºr Name (Produktnummer) - falls Name vom Suchbegriff besser passt
                    if (product.name && product.name !== key && 
                        product.name.toLowerCase().includes(searchTerm) && 
                        !key.toLowerCase().includes(searchTerm)) {
                        const optionByName = document.createElement('option');
                        optionByName.value = key;
                        optionByName.textContent = `${product.name} (${key})`;
                        datalist.appendChild(optionByName);
                    }
                });
                
                // Zeige Anzahl der Ergebnisse (nur bei Suche)
                if (searchTerm && filteredProducts.length > 50) {
                    console.log(`${filteredProducts.length} Produkte gefunden, zeige erste 50`);
                }
            }
        }

        function renderTables() {
            renderProductsTable();
            renderInventoryTable();
            renderDemandTable();
            renderBoms();
        }

        function renderProductsTable() {
            const tbody = document.querySelector('#productsTable tbody');
            tbody.innerHTML = '';
            
            Object.keys(products).forEach(key => {
                const product = products[key];
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${key}</td>
                    <td>${product.name || 'Unbekannt'}</td>
                    <td>${(product.cost || 0).toFixed(2)}</td>
                    <td class="actions">
                        <button onclick="editProduct('${key}')">Bearbeiten</button>
                        <button onclick="deleteProduct('${key}')" class="danger">L√∂schen</button>
                    </td>
                `;
            });
        }

        function renderInventoryTable() {
            const tbody = document.querySelector('#inventoryTable tbody');
            tbody.innerHTML = '';
            
            Object.keys(products).forEach(key => {
                const product = products[key];
                const quantity = inventory[key] || 0;
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${key}</td>
                    <td>${product.name}</td>
                    <td>${quantity}</td>
                    <td class="actions">
                        <button onclick="deleteInventory('${key}')" class="danger">L√∂schen</button>
                    </td>
                `;
            });
        }

        function renderDemandTable() {
            const tbody = document.querySelector('#demandTable tbody');
            tbody.innerHTML = '';
            
            Object.keys(demand).forEach(key => {
                if (products[key]) {
                    const product = products[key];
                    const quantity = demand[key];
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${key}</td>
                        <td>${product.name}</td>
                        <td>${quantity}</td>
                        <td class="actions">
                            <button onclick="deleteDemand('${key}')" class="danger">L√∂schen</button>
                        </td>
                    `;
                }
            });
        }

        function renderBoms() {
            const display = document.getElementById('bomsDisplay');
            display.innerHTML = '';
            
            Object.keys(boms).forEach(productNumber => {
                const productName = products[productNumber] ? products[productNumber].name : 'Unbekannt';
                const bomDiv = document.createElement('div');
                bomDiv.className = 'card';
                bomDiv.style.marginBottom = '10px';
                
                let html = `<h4>${productNumber} - ${productName}</h4><ul>`;
                Object.keys(boms[productNumber]).forEach(component => {
                    const componentName = products[component] ? products[component].name : 'Unbekannt';
                    const quantity = boms[productNumber][component];
                    html += `<li>${component} - ${componentName}: ${quantity} St√ºck</li>`;
                });
                html += `</ul><button onclick="editBom('${productNumber}')">Bearbeiten</button><button onclick="deleteBom('${productNumber}')" class="danger">St√ºckliste l√∂schen</button>`;
                
                bomDiv.innerHTML = html;
                display.appendChild(bomDiv);
            });
        }

        // L√∂schfunktionen
        function deleteInventory(productNumber) {
            if (confirm('Lagerstand l√∂schen?')) {
                delete inventory[productNumber];
                saveData();
                renderTables();
                showAlert('Lagerstand gel√∂scht!', 'success');
            }
        }

        function deleteDemand(productNumber) {
            if (confirm('Bedarf l√∂schen?')) {
                delete demand[productNumber];
                saveData();
                renderTables();
                showAlert('Bedarf gel√∂scht!', 'success');
            }
        }

        function editBom(productNumber) {
            // Aktuelles BOM-Formular leeren
            document.getElementById('bomProduct').value = productNumber;
            document.getElementById('bomItems').innerHTML = '';
            
            // Bestehende Komponenten laden
            if (boms[productNumber]) {
                Object.keys(boms[productNumber]).forEach(component => {
                    const quantity = boms[productNumber][component];
                    const bomItems = document.getElementById('bomItems');
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'bom-item';
                    
                    itemDiv.innerHTML = `
                        <select required>
                            <option value="">Bauteil w√§hlen...</option>
                            ${Object.keys(products).map(key => 
                                `<option value="${key}" ${key === component ? 'selected' : ''}>${key} - ${products[key].name}</option>`
                            ).join('')}
                        </select>
                        <input type="number" placeholder="Menge" required min="1" value="${quantity}">
                        <button type="button" onclick="this.parentElement.remove()">Entfernen</button>
                    `;
                    
                    bomItems.appendChild(itemDiv);
                });
            }
            
            // Zum St√ºcklisten-Tab wechseln
            showTab('boms');
            
            showAlert('St√ºckliste zur Bearbeitung geladen!', 'success');
        }

        function deleteBom(productNumber) {
            if (confirm('St√ºckliste l√∂schen?')) {
                delete boms[productNumber];
                saveData();
                renderBoms();
                showAlert('St√ºckliste gel√∂scht!', 'success');
            }
        }

        // Datenexport und -import
        function exportData() {
            const data = { products, boms, inventory, demand };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `materialplanung_backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert('Backup erfolgreich heruntergeladen!', 'success');
        }

        function importData() {
            const file = document.getElementById('dataImport').files[0];
            if (!file) {
                showAlert('Bitte eine Datei ausw√§hlen!', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    products = data.products || {};
                    boms = data.boms || {};
                    inventory = data.inventory || {};
                    demand = data.demand || {};
                    
                    saveData();
                    updateProductSelects();
                    renderTables();
                    showAlert('Daten erfolgreich importiert!', 'success');
                } catch (error) {
                    showAlert('Fehler beim Importieren der Daten!', 'error');
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        // Spezifische L√∂schfunktionen f√ºr jeden Tab
        function clearAllProducts() {
            if (confirm('Wirklich alle Produkte l√∂schen? Dies l√∂scht auch alle zugeh√∂rigen St√ºcklisten, Lagerbest√§nde und Bedarfe!')) {
                products = {};
                boms = {};
                inventory = {};
                demand = {};
                
                saveData();
                updateProductSelects();
                renderTables();
                document.getElementById('requirementsResult').innerHTML = '';
                showAlert('Alle Produkte und zugeh√∂rige Daten gel√∂scht!', 'success');
            }
        }

        function clearAllBoms() {
            if (confirm('Wirklich alle St√ºcklisten l√∂schen?')) {
                boms = {};
                
                saveData();
                renderBoms();
                document.getElementById('requirementsResult').innerHTML = '';
                showAlert('Alle St√ºcklisten gel√∂scht!', 'success');
            }
        }

        function clearAllInventory() {
            if (confirm('Wirklich den gesamten Lagerstand l√∂schen?')) {
                inventory = {};
                
                saveData();
                renderTables();
                document.getElementById('requirementsResult').innerHTML = '';
                showAlert('Gesamter Lagerstand gel√∂scht!', 'success');
            }
        }

        function clearAllDemand() {
            if (confirm('Wirklich den gesamten Bedarf l√∂schen?')) {
                demand = {};
                
                saveData();
                renderTables();
                document.getElementById('requirementsResult').innerHTML = '';
                showAlert('Gesamter Bedarf gel√∂scht!', 'success');
            }
        }

        function clearRequirementsResult() {
            document.getElementById('requirementsResult').innerHTML = '';
            showAlert('Bedarfsermittlungs-Ergebnis gel√∂scht!', 'success');
        }

        function clearAllData() {
            if (confirm('Wirklich alle Daten l√∂schen? Dieser Vorgang kann nicht r√ºckg√§ngig gemacht werden!')) {
                products = {};
                boms = {};
                inventory = {};
                demand = {};
                
                localStorage.removeItem('materialplanung');
                updateProductSelects();
                renderTables();
                document.getElementById('requirementsResult').innerHTML = '';
                showAlert('Alle Daten gel√∂scht!', 'success');
            }
        }

        // Kritische Situationen √ºberpr√ºfen
        function checkCriticalSituations() {
            const warnings = [];
            
            // 1. Produkte ohne Kosten
            const productsWithoutCost = Object.keys(products).filter(key => 
                !products[key].cost || products[key].cost === 0);
            if (productsWithoutCost.length > 0) {
                warnings.push({
                    type: 'warning',
                    title: 'Produkte ohne Kosten',
                    message: `${productsWithoutCost.length} Produkte haben keine Kosten definiert`,
                    details: productsWithoutCost.slice(0, 5).join(', ') + (productsWithoutCost.length > 5 ? '...' : '')
                });
            }
            
            // 2. St√ºcklisten mit fehlenden Komponenten
            const missingComponents = [];
            Object.keys(boms).forEach(bomKey => {
                Object.keys(boms[bomKey]).forEach(component => {
                    if (!products[component]) {
                        missingComponents.push(`${bomKey} ‚Üí ${component}`);
                    }
                });
            });
            if (missingComponents.length > 0) {
                warnings.push({
                    type: 'error',
                    title: 'Fehlende Komponenten',
                    message: `${missingComponents.length} St√ºcklisten-Komponenten existieren nicht als Produkte`,
                    details: missingComponents.slice(0, 3).join(', ') + (missingComponents.length > 3 ? '...' : '')
                });
            }
            
            // 3. Bedarf f√ºr nicht existierende Produkte
            const missingDemandProducts = Object.keys(demand).filter(key => !products[key]);
            if (missingDemandProducts.length > 0) {
                warnings.push({
                    type: 'warning',
                    title: 'Bedarf f√ºr unbekannte Produkte',
                    message: `Bedarf f√ºr ${missingDemandProducts.length} nicht existierende Produkte`,
                    details: missingDemandProducts.join(', ')
                });
            }
            
            // 4. Lagerbestand f√ºr nicht existierende Produkte
            const missingInventoryProducts = Object.keys(inventory).filter(key => !products[key]);
            if (missingInventoryProducts.length > 0) {
                warnings.push({
                    type: 'warning',
                    title: 'Lagerbestand f√ºr unbekannte Produkte',
                    message: `Lagerbestand f√ºr ${missingInventoryProducts.length} nicht existierende Produkte`,
                    details: missingInventoryProducts.join(', ')
                });
            }
            
            // 5. Sehr teure Produkte (√ºber 50.000‚Ç¨)
            const expensiveProducts = Object.keys(products).filter(key => 
                products[key].cost && products[key].cost > 50000);
            if (expensiveProducts.length > 0) {
                warnings.push({
                    type: 'info',
                    title: 'Sehr teure Produkte',
                    message: `${expensiveProducts.length} Produkte kosten √ºber 50.000‚Ç¨`,
                    details: expensiveProducts.map(key => `${key}: ${products[key].cost.toFixed(2)}‚Ç¨`).slice(0, 3).join(', ')
                });
            }
            
            // 6. Sehr hohe Lagerbest√§nde (√ºber 10.000 St√ºck)
            const highInventory = Object.keys(inventory).filter(key => 
                inventory[key] > 10000);
            if (highInventory.length > 0) {
                warnings.push({
                    type: 'info',
                    title: 'Sehr hohe Lagerbest√§nde',
                    message: `${highInventory.length} Artikel haben √ºber 10.000 St√ºck im Lager`,
                    details: highInventory.map(key => `${key}: ${inventory[key]} St√ºck`).slice(0, 3).join(', ')
                });
            }
            
            // 7. Zirkul√§re Referenzen in St√ºcklisten
            const circularRefs = detectCircularReferences();
            if (circularRefs.length > 0) {
                warnings.push({
                    type: 'error',
                    title: 'Zirkul√§re Referenzen',
                    message: `${circularRefs.length} zirkul√§re Referenzen in St√ºcklisten erkannt`,
                    details: circularRefs.slice(0, 2).join(', ')
                });
            }
            
            return warnings;
        }

        function detectCircularReferences() {
            const circularRefs = [];
            
            function hasCircularReference(productNumber, path = []) {
                if (path.includes(productNumber)) {
                    const cycle = [...path, productNumber];
                    const cycleStart = cycle.indexOf(productNumber);
                    const actualCycle = cycle.slice(cycleStart);
                    circularRefs.push(actualCycle.join(' ‚Üí '));
                    return true;
                }
                
                if (boms[productNumber]) {
                    const newPath = [...path, productNumber];
                    Object.keys(boms[productNumber]).forEach(component => {
                        hasCircularReference(component, newPath);
                    });
                }
                
                return false;
            }
            
            Object.keys(boms).forEach(productNumber => {
                hasCircularReference(productNumber);
            });
            
            return [...new Set(circularRefs)]; // Duplikate entfernen
        }

        function showCriticalSituations() {
            const warnings = checkCriticalSituations();
            
            if (warnings.length === 0) {
                showAlert('‚úÖ Keine kritischen Situationen erkannt!', 'success', { persistent: false });
                return;
            }
            
            // Zeige die schwerwiegendsten Warnungen zuerst
            const errorWarnings = warnings.filter(w => w.type === 'error');
            const normalWarnings = warnings.filter(w => w.type === 'warning');
            const infoWarnings = warnings.filter(w => w.type === 'info');
            
            let message = `üîç System-Check: ${warnings.length} Situation(en) erkannt\n\n`;
            
            if (errorWarnings.length > 0) {
                message += '‚ùå FEHLER:\n';
                errorWarnings.forEach(warning => {
                    message += `‚Ä¢ ${warning.title}: ${warning.message}\n  ${warning.details}\n`;
                });
                message += '\n';
            }
            
            if (normalWarnings.length > 0) {
                message += '‚ö†Ô∏è WARNUNGEN:\n';
                normalWarnings.forEach(warning => {
                    message += `‚Ä¢ ${warning.title}: ${warning.message}\n  ${warning.details}\n`;
                });
                message += '\n';
            }
            
            if (infoWarnings.length > 0) {
                message += '‚ÑπÔ∏è HINWEISE:\n';
                infoWarnings.forEach(warning => {
                    message += `‚Ä¢ ${warning.title}: ${warning.message}\n  ${warning.details}\n`;
                });
            }
            
            const alertType = errorWarnings.length > 0 ? 'error' : 
                            (normalWarnings.length > 0 ? 'warning' : 'info');
            
            // Generiere System-Check Korrekturen
            const systemCorrections = generateSystemCheckCorrections();
            
            // Erstelle erweiterte Alert-Daten f√ºr System-Check
            const systemAlertData = {
                summary: `System-Check: ${warnings.length} Situation(en) erkannt`,
                errors: errorWarnings.map(w => `${w.title}: ${w.message} - ${w.details}`),
                warnings: normalWarnings.map(w => `${w.title}: ${w.message} - ${w.details}`),
                duplicates: [], // System-Check hat keine Duplikate
                fullMessage: message.trim(),
                corrections: systemCorrections
            };
            
            // Verwende showExpandableAlert f√ºr System-Check mit Korrekturen
            showExpandableAlert(systemAlertData, alertType, { 
                title: 'System-Check Ergebnis',
                persistent: true,
                exportData: true,
                systemInfo: true,
                showCorrections: systemCorrections.length > 0
            });
        }

        function generateSystemCheckCorrections() {
            const corrections = [];
            
            // Fehlende Komponenten in Produktliste erstellen
            const missingComponents = [];
            Object.keys(boms).forEach(bomKey => {
                Object.keys(boms[bomKey]).forEach(component => {
                    if (!products[component] && !missingComponents.includes(component)) {
                        missingComponents.push(component);
                    }
                });
            });
            if (missingComponents.length > 0) {
                corrections.push({
                    type: 'create_missing_components',
                    description: `${missingComponents.length} fehlende St√ºcklisten-Komponenten als Produkte erstellen`,
                    action: () => applyMissingComponentCorrection(missingComponents),
                    severity: 'high'
                });
            }
            
            // Verwaiste Inventar-/Bedarf-Eintr√§ge bereinigen
            const orphanedInventory = Object.keys(inventory).filter(key => !products[key]);
            const orphanedDemand = Object.keys(demand).filter(key => !products[key]);
            if (orphanedInventory.length > 0 || orphanedDemand.length > 0) {
                corrections.push({
                    type: 'cleanup_orphaned',
                    description: `${orphanedInventory.length + orphanedDemand.length} verwaiste Eintr√§ge bereinigen`,
                    action: () => applyOrphanedCleanup(orphanedInventory, orphanedDemand),
                    severity: 'medium'
                });
            }
            
            // Produkte ohne Kosten auf 0‚Ç¨ setzen
            const productsWithoutCost = Object.keys(products).filter(key => 
                !products[key].cost || products[key].cost === 0);
            if (productsWithoutCost.length > 0) {
                corrections.push({
                    type: 'set_zero_costs',
                    description: `${productsWithoutCost.length} Produkte ohne Kosten auf 0‚Ç¨ setzen`,
                    action: () => applyZeroCostCorrection(productsWithoutCost),
                    severity: 'low'
                });
            }
            
            // Zirkul√§re Referenzen bereinigen (Info - keine automatische Korrektur)
            const circularRefs = detectCircularReferences();
            if (circularRefs.length > 0) {
                corrections.push({
                    type: 'circular_refs_info',
                    description: `${circularRefs.length} zirkul√§re Referenzen gefunden - manuelle √úberpr√ºfung erforderlich`,
                    action: () => 'Zirkul√§re Referenzen m√ºssen manuell korrigiert werden',
                    severity: 'high'
                });
            }
            
            return corrections;
        }

        function applyZeroCostCorrection(productsWithoutCost) {
            let fixed = 0;
            productsWithoutCost.forEach(productNumber => {
                if (products[productNumber]) {
                    products[productNumber].cost = 0;
                    fixed++;
                }
            });
            
            if (fixed > 0) {
                saveData();
                renderTables();
                return `${fixed} Produkte mit Kosten 0‚Ç¨ aktualisiert`;
            }
            return 'Keine Korrekturen angewendet';
        }

        // Globale Variable f√ºr Alert-Daten
        let currentAlertData = null;

        // Alert-System mit Export-Funktion
        function showAlert(message, type, options = {}) {
            const existingAlert = document.querySelector('.alert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            
            // Bestimme ob das Alert persistent sein soll
            const isPersistent = options.persistent !== false && (type === 'warning' || type === 'error' || message.length > 100);
            const hasExportableData = options.exportData || (message.includes('\n') && message.length > 50);
            
            // Alert-Header mit Titel und Aktions-Buttons
            if (isPersistent || hasExportableData) {
                const alertHeader = document.createElement('div');
                alertHeader.className = 'alert-header';
                
                const titleElement = document.createElement('div');
                titleElement.className = 'alert-title';
                titleElement.textContent = getAlertTitle(type, options.title);
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'alert-actions';
                
                // Export-Button (wenn exportierbare Daten vorhanden)
                if (hasExportableData) {
                    const exportBtn = document.createElement('button');
                    exportBtn.className = 'alert-btn';
                    exportBtn.innerHTML = 'üìä Export';
                    exportBtn.title = 'Warnungen als Textdatei exportieren';
                    exportBtn.onclick = () => exportAlertData(message, type, options);
                    actionsDiv.appendChild(exportBtn);
                }
                
                // Schlie√üen-Button (f√ºr persistente Alerts)
                if (isPersistent) {
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'alert-btn';
                    closeBtn.innerHTML = '‚úï Schlie√üen';
                    closeBtn.title = 'Warnung schlie√üen';
                    closeBtn.onclick = () => alert.remove();
                    actionsDiv.appendChild(closeBtn);
                }
                
                alertHeader.appendChild(titleElement);
                alertHeader.appendChild(actionsDiv);
                alert.appendChild(alertHeader);
            }
            
            // Alert-Content
            const contentDiv = document.createElement('div');
            contentDiv.className = 'alert-content';
            
            // Mehrzeilige Nachrichten unterst√ºtzen
            if (message.includes('\n')) {
                contentDiv.style.whiteSpace = 'pre-line';
                contentDiv.style.textAlign = 'left';
                contentDiv.style.maxHeight = isPersistent ? '400px' : '300px';
                contentDiv.style.overflowY = 'auto';
            }
            
            contentDiv.textContent = message;
            alert.appendChild(contentDiv);
            
            // Alert-Daten f√ºr Export speichern
            currentAlertData = {
                message,
                type,
                timestamp: new Date().toLocaleString('de-DE'),
                options
            };
            
            document.querySelector('.container').insertBefore(alert, document.querySelector('.tabs'));
            
            // Auto-Remove nur f√ºr nicht-persistente Alerts
            if (!isPersistent) {
                const displayTime = message.length > 100 ? 8000 : 5000;
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.remove();
                    }
                }, displayTime);
            }
        }

        function getAlertTitle(type, customTitle) {
            if (customTitle) return customTitle;
            
            const titles = {
                'success': '‚úÖ Erfolgreich',
                'error': '‚ùå Fehler',
                'warning': '‚ö†Ô∏è Warnung',
                'info': '‚ÑπÔ∏è Information'
            };
            
            return titles[type] || 'Benachrichtigung';
        }

        function exportAlertData(message, type, options) {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `Materialplanung_${type}_${timestamp}.txt`;
                
                let exportContent = `MATERIALPLANUNG - ${getAlertTitle(type, options.title).toUpperCase()}\n`;
                exportContent += `Zeitpunkt: ${new Date().toLocaleString('de-DE')}\n`;
                exportContent += `Typ: ${type.toUpperCase()}\n`;
                exportContent += `\n${'='.repeat(50)}\n\n`;
                exportContent += message;
                exportContent += `\n\n${'='.repeat(50)}\n`;
                exportContent += `Export erstellt mit Materialplanung System\n`;
                
                // Zus√§tzliche System-Informationen anh√§ngen
                if (options.systemInfo) {
                    exportContent += `\nSystem-Status:\n`;
                    exportContent += `- Produkte: ${Object.keys(products).length}\n`;
                    exportContent += `- St√ºcklisten: ${Object.keys(boms).length}\n`;
                    exportContent += `- Lagerbest√§nde: ${Object.keys(inventory).length}\n`;
                    exportContent += `- Bedarfe: ${Object.keys(demand).length}\n`;
                }
                
                const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                
                URL.revokeObjectURL(link.href);
                
                // Kurze Best√§tigung (nicht persistent)
                setTimeout(() => {
                    const confirmAlert = document.createElement('div');
                    confirmAlert.className = 'alert success';
                    confirmAlert.style.position = 'fixed';
                    confirmAlert.style.top = '20px';
                    confirmAlert.style.right = '20px';
                    confirmAlert.style.zIndex = '10000';
                    confirmAlert.style.maxWidth = '300px';
                    confirmAlert.textContent = `üìÅ Export gespeichert: ${filename}`;
                    document.body.appendChild(confirmAlert);
                    
                    setTimeout(() => {
                        if (confirmAlert.parentNode) {
                            confirmAlert.remove();
                        }
                    }, 3000);
                }, 100);
                
            } catch (error) {
                console.error('Export-Fehler:', error);
                alert('Fehler beim Export der Daten. Bitte versuchen Sie es erneut.');
            }
        }
    </script>
</body>
</html>